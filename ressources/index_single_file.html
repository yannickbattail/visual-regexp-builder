<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Visual RegExp builder</title>
<style type="text/css">
/* schema_custom.css */
#schema {
	min-height: 50px;
	margin: 0px;
}

.mainGroup {
	padding: 8px;
	padding-top: 0px;
	background-color: LightYellow;
}

#regexp {
	font-size: 16px;
	font-weight: bold;
	width: 400px;
	border-radius: 3px;
	border-width: 2px;
	border-style: inset;
}

.regexpOk {
	background-color: PaleGreen;
}

.regexpFailed {
	background-color: Tomato;
}

#errMsg {
	background-color: LightGray;
}

.item {
	border-width: 2px;
	border-style: outset;
	border-radius: 10px;
	padding: 2px;
	margin-left: 20px;
	margin: 8px;
	background-color: Khaki;
	/*background-color: Chartreuse;*/
}

.itemClass {
	border-width: 2px;
	border-style: outset;
	border-radius: 10px;
	padding: 2px;
	margin-left: 20px;
	margin: 8px;
	background-color: Turquoise;
	/*background-color: Chartreuse;*/
}

.group {
	border-width: 2px;
	border-style: inset;
	border-radius: 3px;
	padding: 3px;
	margin: 0px;
	background-color: LightYellow;
}

.mainGroup>.group {
	border-style: none;
}

.groupClass {
	border-width: 2px;
	border-style: inset;
	border-radius: 3px;
	padding: 3px;
	margin: 0px;
	background-color: LightCyan;
}

.showQuantifier {
	display: inline;
}

input:focus {
	background-color: AliceBlue;
}

[draggable=true] {
	cursor: move;
}

ul {
	margin: 2px;
	padding-left: 20px;
}

fieldset {
	border-radius: 5px;
	border-style: solid;
	border-width: 2px;
	border-color: black;
	padding: 5px;
	padding-top: 0px;
}

#recycledBin {
	background-repeat: no-repeat;
	background-position: center;
	background-image:
		url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAUwwAAFMMBFXBNQgAAAAd0SU1FB9sEARUUBb04xagAAAluSURBVGje3VltjFxVGX7OuR8zc2d2ZzvdblepaNrYsqKiQbDVElkiJPgRIwQkgjGaEPjRxAh/DEYbiX+UX+ovMWpixMQErD8wEY1BitBSkFBKKTVIwbY7252dO9935n6c9/XHnXNnZrvbnZndYuJNbu6de2buvM/7Ps/7vuccgTGPX//2MXzjnrsHnj308A+35fOTWyccx8nn8xnHcdJREHYq9VqnUql6brXq/ugHBy9gEw8x7Bd//8QhfOX2LwMAfvf4E5+8Yvv2T6XTqWvT6cy1hpQ7mcm2DANCSgAMpQi1Wg2WZSGVSsEyTUjDQKQUmBEJgTORUi8HQfDS6X+fOXr3Hbf/Y+X/bCqAvx0+fGfY8e81pPhsyrZh2zYcx+FMJiOUUiAi6Ku+r1QqsG0bhmHANM2LTtu22bIsYVkWyq6Lar1+uOV1fnnLTTf+ZsMA/vr0M7h5/jM4cuzlBxeL535cr1YkAM7lciKTycBxHORyOTiOA2aGUio5iQhRFMF1Xdi2DdM0YVlWYrhlWQOfbdtGs9lErVZjr9USoSJkJ/MP7997/UFtx0gAnjv6IiKlHNsyX3/x6PPvb7fbnMlkEsO18dlsFtlsFgAQRdEAAKUUSqUSUqnUAAANyLZtWJYFuxvNarWKUqkE13VRr9cRRRGu/ujHyiqiqwzTWN6/7/pVAZirPfz03uvwz1dee+qFI89eWSwWkclkhJQSQoiEDkEQIJVKQSkFZk4A6CsRodPpgJlhWRaYGQBgGEYCmJmTaNVqNbium1wrlQoWiouFL37ptuc/8fGP7F4rAuZaA9mcs7+0VILneb1wCZF4MwxDhGGIlfxn5sRY/Rtmhu/7CSAA0A4RQkBKiVarhWazCdd1US6X0Ww04Hltkc1lP7hUcidmthUaIwHwmk3cdPMt+NUvfg7bthEEQRL6KIoSY7Ux2ljt0U6ng2q1CsMwIKWEYRjJvTZc/5aZ4bouisUiyuUyGo0G3HIZB771bYAJwlxbq2sCKJ4/i6s+dDXuve9+/OynP0EYBJienkahUIDv+4iiCGEYwvM8hGGIIAjQ6XQSSgFAvV5PuK+N12AAgIgQBAFarRaWlpZQLpfhui4y6TQe+t73sWvnLrTb7UsmyzVHnnzySZ6cnMSOK96H6e0zePbwYfzx0B/w2okT2DYzg5mZGWzduhWFQgGWZcEwjMSr2rhyuTwwpr2twYdhCCJCq9VEsbiIK3bswK23fg77b7gBi4sXAAEIFsgX8vltW7bURwaQz+dRKBQwPb0NU1NTMEwTnufhpReP4dVXT2BhYQGl0hKYeSDbaIrUarWEMjrVauNt28bc3Bz27t2L2dlZfGDnLgR+gHMLRTRqdUjTwFQ+DwFGvjC1JgBzqGIhAMOQMKTARC6L+fl5zM/PJ+P1egOVSgXLy8uoVivw/QBhGMDzvG66tJFOpzA1tQWz27dj6/RWZLNZMHOimyAMcPzESUACtmkilhWD17HNHLcH0TxXRLBtG9PT08hN5BD470HGySZ00RkqVBHCIEKn4+Ott/8DYsBxMrhyx3tBxAjDCIoIljRGaRDGB6BpEfMw9mIYhmh5bUAakEJCkYKKCJGKoEiBVAxGSAlEhHa7A98PutTS4o/pJ+IAXD4AayNjgHnQiUJAJA96A1EUwfcDREoBRIm9QghAGCAw5Dp/Jy9HO5uy7aHcx2AQqTg6zIOYwUNFQA7L9/4UebEhg4cfhEMKKQbBtLJ6a9esL+INR4CTP1wZETFU/JgAMIP6AUAAImbiZdeA2ODvqds7cb/7+zWzDopNFTGPl48HvS96EWVmsBDvHoBxosHEMdN5vDeZ/1Pviy6FaBCA6OqAh3jxptcBHjESzDSoAV0HklZikyike/5NB6wnQDQYAgER61fw+GlUv1z3M8MIciwRg8FMA/QZlphyPeP7z0uCYB47AnEm6ne/iDMRb0ADullbLQJ6RrUZbVMs4sGam6TRjUZAL1L1T9aDIFgnEmNqgEmTv1eleX0QQ1NITxP7l0s2nEpFv85wUSsxVHJZs8T3eb3/Xn9eC0TcR/IIERBgUDfj9OjbayU2QcRrUarT6axqrBgpAvFERrfTAoCQsQ5W1oexAPQbvXLhipnRbndASfxHbCa66T9u6MYTlTlsBFYzXl9rtSpsyx67dsd1TA2uInTT69i90ErOryZq7oadGahUq925gRipnSCKDU30JAQMCCiBjfVCqxWyi8/BfsZre/A7Phwne8kZ3Mpp5coZWbyg1RsXl2hjRqrEOhL9eojve9/xwwCLi0V4XqvbP/G6dSBuJXoijicFPQa9feaM2BQAF9OJkisx94AQo1KpYOnCBRARpFg7tTL1FTMx2E4LKVAqlZBzMmJDWUj3QatlI51BmCgGRBoY4AcBzp07j+VSCaSiVSOSOIMG58RSStSqFdQqtTivbqYGNIi43MeGE3H3WRwNyQQmghAC7baHWq0OyzKQzmThZDOQhoTi+Pux9xmAhJBxC7FcXsbS0hJStgU/8EdfXr/I06vWAeqLUnesjxLU7XGIASEF/CBAs+VBXVAQQsJO2bBMC9SNcKvVgiElgkIbYRB21SxxzdUf9kcGUKlU/jQxMfF5XaR6Xkef0eh5X4Nh7i5YUZ9OevTSK9dKKTQbTTADKooQUYQwjJDLOjCkRNSN71tvvnkKgDeyBg4cOHCf53ktKSWvXQt4gMNMMQBScQYhoqRdJqIBYJQIX0Ght9uTrLaakpvNBn/3oe98c9wZ2fm77rrrmnfeeedflmV1Hb9aa0G9LMQEIgVGLHi93kmsukLvz17o0ovAqvs+JrAAp1IpvP3WmeWvf+2eG5vN5guXArDezKRy6NChR3O5HO/evfu6iYkJWynFRCT0ziMD8Ds+ojBEGIQIAx+mZccVmgiKVjSBxFA6ot1xJgKB2bZSwl0uhUeOPPfYgw88cBuA1zdzKWfy4MGD9+/bt++rc3Nz12Sz2WSXstFowvM8eG0PrZYHx8lCSr3h19sAV3o3M75nBoSARKNRx8mTr71x7IWjjz/z96cfBXD2cq8M7nzkkUe+sGfPnhtmZ2evNy3rStu20Wq10Gg0kclkYqESxXsCrMAqpk0YhSgvu1hYOH/27PlzL58+derZvzz156cAvAEgereXNvU7JgFsu+OOO+emtmyZyU9OTqXT6bxl206z2ey0Pa9Wq9errx4/Xjp+/JXTAJYA1MYx+P/u+C9eyMhhYWjjcAAAAABJRU5ErkJggg==);
}

.recycledBinFull {
	background-image:
		url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAUwwAAFMMBFXBNQgAAAAd0SU1FB9sEAhAxIX22nJsAAAuUSURBVGje1ZprjB3lecd/7ztzzpzbrvfivRsbm+AUE2gJdoLagGoqDC0lrfqlTT6katVgpLRJoIWISm3aRioxROotqXpJUJFIUxUIkaIkpiqItlxCgi8EfANsvPZ613s5ezuXOTPzXvphZs5evPaeXZtUHWl0Zuaceee5/P//53nnPfB/sL3x8V//xoG7737y3BNPdL551138P9o+nj35vc0PTfzlx+zw5m3mxU2b9EvQu1/KdY8o1nPTE//6LX77k59Ycu0vHn1saLC/f/NQf393Pp/Lu65bEIgckka93vCv33Hj7QU5t3fDyEe4848K1nvdZ+/cBJVc8clPNGqf+qk5sO/v/r604wPbfq1jw4afz3vezbl87uZsJuM6UmKtRWuN1pogCAhDTX9/P14hT6Q82o9ex5PP5/jzf4GtXe/wzc+Bs+uEOjw28pnTp9599v7P7J0ECwgeevRRHn3ooctz4Ls/eI57fvlOvvXUs/n+/t7767XqvS5ii5tx8LJZWygWRbFYBGtRWmOMQRlNww/o6trI0FAf1gBOEf/NT1GZPMItn64S1EY59niVsa7H0Bvutv19nWJioow1QTnj5Z7Z/8LLX374c/e+98PD73DLz127Pgf+44UX2XP7L/I/r/7wH8pTU3vHR0dwHJdisUihUKBUKjU/hRBoFSGcDK6boa29jbZCHmMtQmbwx77LQPS33PDJGieHy3zni6MMXns7/qZ/5NptPVhr8DyPKIrIZjOcGxvn4BtHvz1bnv6tq7ddFd35S7sv6oC70sXZWoM3Dh8afPXHB04ef+vN3JkzwxSLRfL5PI7j4DgO2WyWTCaDUgproae3n+PHj3PjDdfjeVmMMWhjMY1JBqK/4b6vtDM5M8Xv3zPOzht7ecV+iRu6PaQrMQrCMGBuvkq9VmPr1q2oMPyNSt0PlNU/Q5638Vd2YEX6dxRzCMSrQeB7B17/MVEU0mg0mnsQBFSqVaJIU6vX6ejqI5srsnPXRzhw4CATExMEQYghT+7sZ/n+4Zv49nPvsK1nki/9ruYwX2XzYCfFUpF6PWD0/DhT5WnqdR8nW+Dke8McOXKEWmWerOO9dDHjL5oBgJ6ens1TU1M0goBarY61IIRACGhr38Du3btxpIN0HKZn5mg0Qup1zY4d19Hb24sfWPTZr2AKH+L3/vgZMq7m2T+b46Wpe9Eb+/G8HJPTFc6fH2X71qvIeh6Vqk8h5+LLDJ1dG5GZrPC8bE95Zra7u7Oj3HIGAPxalYH+Pj77+fvZuu0afN8nn8+zZcs27rhjD1pbhBRgNL0bO+lsz9DbXQLhUK35VEf309M1wz33/TdhBF+/f5IZ+7O8fHons/MVIqUJ6hU+eM1mHNclDEMajTrjk1OMjIzg5TL09/Xhug7ZTDZacwbOj50lX8zT3d3NHXvuYG5mlrb2EoVcHq1CKtUqHR0dOEISKZXcFdLV2U61ruksRXzhy2/z7ulxPn3XLLt35vjqofu46UNX8Qu37ERbaPg+UaRoNKpUq1Xq9TqNIGBwaIjOjm6M1QR+QGTU2iEEkomxMSTQ1dXNxp5epsvTTE1PE0Wajo52RkbO0dnZSb6QR4URUgrCMEQIybtTV/NP33ydG7bneGTvHH/1X39Ad3+JqzYNUvdDqtV5KpUKvu+jtaZQKDAwNERPTx9B0GB6egbXdRHYS8qoe6kvpZSoKEJYTUfbBkr5PGZwAGstlUqFUklRrVQ4NzJCd2cXY+NjdHR0kM1mcTN5Bvo7+evfOc7XfnAT78y6fLgnxBjL+Ph5CoU8PT09dHZ20dZWwlrLVHma08PD+H6DTMalvb191ULmtlqwpZTkcgs/97wsWmv6envZ/sHtOFJy3fXXAWAtGGM48tZRrBR8eNloSmnCIKDeCPA8D7/RwBjDyfeGsdaSzWRiwbAChL0SDqy8GWNoNGpUq3UqtQpRGBGqiE2Dm8hms3FrEWlCrVBaEYURQRCijcZasNZy9ZZNaG0Q1hJGimwmA0LE0BGWVRC0fgeklAghkTIpbG4WrQw6aqC0QioHbTRaxe2F0SZ+oOsijIivW4WKNJFSSMAk1goBCAdjLZL3IQPW2mZNkFIipEBIgZQCxxFI6bBq6JpjGSwWa5dCttUuU67F4ObwyXHshEAKiRQyvi4EGafFuCQwssZirWmavfhZ9ko4cGkYxdFfcMYhVFHLnbpJnNB2ob0Uyae19kqp0Aq6FAO1abgQMtnjOIo1wNFas+iO9P6kAqzixGVloMkBEeNfCtE8b51PJlYks4jAjmimx75fGVho7mIOiJTMQqx5HGtjuRQrTlPE+wUhlkBINmEkWlagFOexA3bJ2E0ImfeRxOnT4sizyBGxJkm21jZrAICwIgmQvTIqlKrBSqogmnIqY+OlxNo1QMhYjDXx3HkJakRybZ0kFkIsRMcYjDHNa0uldAE66+JAUsSsMU0NkiQ9UAuthLxU1FPD0+MoilYwUCAFMYmFRMYnrbKgGaTFcUklupVMuqsNvASnSZQymcyybMlEQpNstB7+JoHtEkym2rO6B3JVciVZSDMRRRFRFF0At8U8WI8KLS1msTjE6rpODqQGL4586kij0UBr3YxRiv0YPiLV2BZbieQZS2S09VouV+v3l2ciPQ+CAK11s+xLKZNPsYb3lSKGj7VxUyRSo5Ix7GWQeHHUUwcW0r3MiRRCCQcsa5TRRInSuNskibYFMLqrq8OFxi/+jd9oIBA4jpO01WJNb4ybCmQuZqpZfyuxUtRTh1zXbUatUqngOC5uxgVnbcU9LmIWu9hQEc/PYghdRi+0OPrGmAXiNrNgk8mOxffrhPMhhXwRpGxJiFK4kExqUvWRCAxitTbo0hzQWq8Y/QsgBSR0QSvNxOQEOnlH1BKEtI2r8SJzhVjgAyKeR6+7Diw3enldSDXcGBNrN5bxiXHK5XJLcphKaJyAhD9Jc2iTdYef/ORNcVmFbLnhy7lhTEruGLNCCOo1n5EzZ6nVKjiX6JGa4ywisUiquyMdRkdHGRjoE+tSoVRKl2cjJbgQAmtMnIFF/Yw1cXNsBZTLZSanJmlra6dUbMNKu0Rw0glNMwBpIROWsyNniIKQ906dci6bxMuPL1ApE78eEdZghbwgAOXyFBMTE+S8HIVSkUwmi0wUSyTNj+O4SClpNBqUy5PUajXynsdz338ut1YHskEQqFwu5xhjRLp4t7ylIClAqSNxUybAGoxhITvGNif7db/G3PwcYaRwJGQ8D60s1iqq1ToZ12Fo0yDJ8BhjeOyxfbNr5YA6duzYv7uuK1Yi84ITFp1AxyTfxeRjEaxs4tACXwBcR6KMxa/5+H6VWq2OUipuy5FIAY7jcOjQwe/BxddoLuaAeeSRRx4+evTosWw2m6BgwQml1ELUjU6KUWIwi4xPSZ9CzJomYdMCZozB6NgxgwErkEJY1/M4ceL46S/+6Z98/lLl+KIqtHPnzjMPPvjgrz799NPfyeVyIp2NpYYLAVobtDaLDIqrp7EpfGzzlYlJ5TKpuiZ+o4UxujmusALpCDzPE/+5f//zD3/hwT2bt2x593IXujeUSqVfefzxx//wtttuuzmKIsIwtPl8XqQ1YH6+Gs8TlMJojTIGnWRJa43SBqMV2hiUMhijUNpitEYbFeNPShEpw9G33jj44gvP//Nrr732b8DsFVmpz2azhGHYBXx03759v3nrrbfu2bFjx0AURfGKZWWeIIiIVBQvdiuD0gqrNdoki+BaoYzBKIPBWGsQUgqiSHHi7eNnDh088PwzTz31DPAjYKrVWdF6/iuRAbqAax544IGP7dq166PFYvEDbW3tfe0b2vs8L4dS8VqA1gplAaOIlGZ6ZsZMl8sTs7Oz48Onh08cPHjgR6+8/NIrwGnHcaa01tFP5c8eKzjkAnmgkOxt27dvb+/t68uPnjvXOHXqVAWYB+pADfCFEMpaG13uw/8XmY7FNrkZwvYAAAAASUVORK5CYII=)
		!important;
}

#regexp {
	width: 100%;
}

#saved_regexp {
	width: 100%;
}

#test {
	width: 500px;
	height: 100px;
}

#result {
	width: 500px;
	height: 100px;
}

#code {
	width: 500px;
	height: 100px;
}

#quantifierBlock {
	background-color: white;
	padding: 5px;
	width: 350px;
	border-radius: 5px;
	border-style: solid;
	border-width: 2px;
	border-color: black;
}
</style>
<style type="text/css">
/* schema_mandatory.css */
#design {
	
}

#design>tr>td {
	
}

#buttons {
	display: none;
	position: absolute;
	background-color: white;
	border-width: 1px;
	border-style: solid;
}

.button {
	background-color: white;
	border-width: 1px;
	border-style: dotted;
}

.button:hover {
	background-color: grey;
}

#actionBar {
	font-weight: bold;
}

#close {
	display: inline;
	float: right;
}

#close:hover {
	background-color: grey;
}

.item {
	display: block;
}

.showButtons {
	display: inline;
}

.quantifier {
	display: inline;
}

#quantifierBlock {
	display: none;
	position:absolute;
	top:0px;
	left:0px;
}

#schema {
	width: 500px;
}

#recycledBin {
	width: 100px;
	height: 100px;
}

#ressources {
	width: 400px;
}
</style>

<!-- <link rel="stylesheet" href="apg.css" type="text/css" /> -->
<!-- include APG library -->
<script type="text/javascript">
/* apgLib.js */
/********************************************************************
  APG - an ABNF Parser Generator
  Copyright (C) 2009 Coast to Coast Research, Inc.
 
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see
  <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
  or write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
	  author: Lowell Thomas
	          lowell@coasttocoastresearch.com
	          http://www.coasttocoastresearch.com

*********************************************************************/
/*global
isArray, stateToString, opcodeToString
*/
"use strict";
// opcode operator types
var ALT = 1;
var CAT = 2;
var REP = 3;
var RNM = 4;
var TRG = 5;
var TLS = 6;
var TBS = 7;
var PRD = 8;

// opcode syntactic predicate types
var APG_NOT = 0;
var APG_AND = 1;

// opcode & syntax analysis states
var APG_ACTIVE = 1;
var APG_MATCH = 2;
var APG_EMPTY = 3;
var APG_NOMATCH = 4;

// opcode execution return state
var OP_STATE = 0;
var OP_MATCHED = 1;

// semantic analysis callback states
var APG_PRE = 5;
var APG_POST = 6;

// semantic analysis callback return values
var APG_SEM_OK = 1;
var APG_SEM_ERROR = 0;
var APG_SEM_SKIP = 2;

/*CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC*/
// the APG library class
function ApgLib(strings, rules, ops)
{
    this.constructed = false;
    /*****************************************************************************/
    this.clear = function()
    {
        this.startRule = 0;
        this.ruleCount = this.rules.length;
        this.stats = null;
        this.ast = null;
        this.chars = null;
        this.charEOS = 0;
        this.treeDepth = 0;
        this.trace = null;
        this.stats = null;
        this.syntax = null;
        this.syntaxData = null;
        this.semantic = null;
        this.state = [APG_ACTIVE, 0];
    };
    while(true)
    {
        // validate the input
        if(!isArray(strings)){break;}
        if(!isArray(rules)){break;}
        if(!isArray(ops)){break;}
        if(rules.length === 0){break;}
        if(ops.length === 0){break;}
        
        // initialize the object
        this.strings = strings;
        this.rules = rules;
        this.opcodes = ops;
        this.constructed = true;
        this.clear();
        break;
    }
    
    /*****************************************************************************/
    // initialize APG for syntax analysis
    // list - an array of syntax call back function pointers
    this.syntaxInit = function(list)
    {
        this.syntax = [];
        if(isArray(list) && list.length > 0)
        {
            for(var i = 0; i < list.length; i+=1)
            {
                if(list[i]){this.syntax[i] = list[i];}
                else{this.syntax[i] = false;}
            }
        }
    };

    /*****************************************************************************/
    // initialize APG for semantic analysis
    // list - an array of semantic call back function pointers
    this.semanticInit = function(list)
    {
        this.semantic = [];
        if(isArray(list) && list.length > 0)
        {
            for(var i = 0; i < list.length; i+=1)
            {
                if(list[i]){this.semantic[i] = list[i];}
            }
        }
    };
    
    /*****************************************************************************/
    // initialize APG for AST generation (required if doing semantic analysis)
    // ast - a previously constructed AST object
    this.astInit = function(ast)
    {
        this.ast = ast;
    };
    
    /*****************************************************************************/
    // initialize APG for tracing the parser
    // trace - a previously constructed Trace object
    this.traceInit = function(trace)
    {
        if(trace){this.trace = trace;}
        else{this.trace = null;}
        
    };
    
    /*****************************************************************************/
    // initialize APG for statistics collection
    // stats - a previously constructed Stats object
    this.statsInit = function(stats)
    {
        this.stats = stats;
    };
    
    /*****************************************************************************/
    // displays the collected statistics
    // caption - optional caption for the statistics table
    this.stateDisplay = function(caption)
    {
        var html = '';
        if(this.stats)
        {
            html += '<table id="state-display">';
            if(typeof(caption) === 'string')
            {
                html += '<caption>PARSER STATE</caption>';
            }
            html += '<tr><th>Parser State:</th><td>'+stateToString(this.state[OP_STATE])+'</td></tr>';
            html += '<tr><th>Characters Input:</th><td>'+this.charEOS+'</td></tr>';
            html += '<tr><th>Characters Matched:</th><td>'+this.state[OP_MATCHED]+'</td></tr>';
            html += '</table>';
        }
        return html;
    };
    
    /*****************************************************************************/
    // evaluate any rule name
    // can be called from syntax call back functions for handwritten parsing
    // ruleIndex - index of the rule to execute (see the opcodes)
    // charIndex - what phrase to parser, offset into the input string
    // state - array to return the final state (OP_STATE) and number of matched characters (OP_MATCH)
    this.evaluateRule = function(ruleIndex, charIndex, state)
    {
        var length, valid = (ruleIndex < this.rules.length) && (charIndex < this.chars.length);
        if(valid)
        {
            // create a dummy RNM operator
            length = this.opcodes.length;
            this.opcodes[length] = [];
            this.opcodes[length].opNext = length + 1;
            this.opcodes[length].type = RNM;
            this.opcodes[length].ruleIndex = ruleIndex;
            this.opExecute(length, charIndex, state);
            this.opcodes.length = length;
        }
    };
    
    /*****************************************************************************/
    // parses the input string
    // start - the index of the start rule
    // input - array of character codes of the input string
    // data - options user-defined data, is passed to the syntax call back functions
    this.syntaxAnalysis = function(start, input, data)
    {
        var ret = false, startOpIndex;
        while(true)
        {
            // validate input
            if(typeof(start) !== 'number'){break;}
            if(!isArray(input)){break;}
            if(start >= this.ruleCount){break;}
            
            // initialize
            this.chars = input;
            this.charEOS = input.length; 
            this.startRule = start;
            this.syntaxData = data;
            if(this.ast){this.ast.ast.length = 0;}
            
            // create a dummy opcode for the start rule
            startOpIndex = this.opcodes.length;
            this.opcodes.push({'type':RNM, 'opCount':1, 'ruleIndex':this.startRule});
            
            // execute the start rule
            this.opExecute(startOpIndex, 0, this.state);
            this.opcodes.pop();
            
            // test the result
            if(this.state[OP_STATE] === APG_ACTIVE){break;}
            if(this.state[OP_MATCHED] !== this.charEOS){this.state[OP_STATE] = APG_NOMATCH;}
            if(this.state[OP_STATE] !== APG_NOMATCH){ret = true;}
            
            // success
            break;
        }
        return ret;
    };
    
    /*****************************************************************************/
    // translate the rule named phrases into APG JavaScript opcodes
    // data - optional user-defined data, passed to the semantic call back functions
    this.semanticAnalysis = function(data)
    {
        var i, forRet, ast, ret, downIndex, ruleIndex, upIndex, name, index, count;
        ret = false;
        //var lineNo = 0;
        if(this.ast !== null)
        {
            ast = this.ast.ast;
            forRet = true;
            for(i=0; i < ast.length; i+=1)
            {
                if(ast[i].down)
                {
                    downIndex = i;
                    ruleIndex = ast[downIndex].ruleIndex;
                    if(this.semantic[ruleIndex])
                    {
                        upIndex = ast[downIndex].upIndex;
                        name = rules[ruleIndex].rule;
                        index = ast[upIndex].phraseIndex;
                        count = ast[upIndex].phraseLength;
                        ret = this.semantic[ruleIndex](APG_PRE, this.chars, index, count, data);
                        if(ret === APG_SEM_SKIP){i = upIndex;}
                        else if(ret !== APG_SEM_OK){forRet = false; break;}
                    }
                }
                else
                {
                    upIndex = i;
                    downIndex = ast[upIndex].downIndex;
                    ruleIndex = ast[downIndex].ruleIndex;
                    if(this.semantic[ruleIndex])
                    {
                        upIndex = ast[downIndex].upIndex;
                        name = rules[ruleIndex].rule;
                        index = ast[upIndex].phraseIndex;
                        count = ast[upIndex].phraseLength;
                        ret = this.semantic[ruleIndex](APG_POST, this.chars, index, count, data);
                        if(ret !== APG_SEM_OK){forRet = false; break;}
                    }
                }
            }
            ret = forRet;
        }
        return ret;
    };
    
    /*****************************************************************************/
    // the ALTERNATION operator
    // opIndex - index of the ALT operator opcode
    // charIndex - input string index of the phrase to be parsed
    // state - array for return of the final state and matched phrase length
    this.opALT = function(opIndex, charIndex, state)
    {
        state[OP_STATE] = APG_NOMATCH;
        state[OP_MATCHED] = 0;
        var childOpIndex, op = this.opcodes[opIndex];
        if(op.type !== ALT){throw ['opALT: type ' + opcodeToString(op.type) +' not ALT'];}
        childOpIndex = opIndex + 1;
        for(; childOpIndex < op.opNext; childOpIndex = this.opcodes[childOpIndex].opNext)
        {
            this.opExecute(childOpIndex, charIndex, state);
            if(state[OP_STATE] !== APG_NOMATCH){break;}
            else if(this.stats !== null){this.stats.backtrack(op);}
        }
    };
    /*****************************************************************************/
    // the CONCATENATION operator
    this.opCAT = function(opIndex, charIndex, state)
    {
        state[OP_STATE] = APG_NOMATCH;
        state[OP_MATCHED] = 0;
        var op, astLength, catState, catCharIndex, catMatched, childOpIndex;
        op = this.opcodes[opIndex];
        if(op.type !== CAT){throw ['opCAT: type ' + opcodeToString(op.type) +' not CAT'];}
        astLength = (this.ast) ? this.ast.currentLength() : 0;
        catState = [APG_NOMATCH, 0];
        catCharIndex = charIndex;
        catMatched = 0;
        childOpIndex = opIndex + 1;
        for(; childOpIndex < op.opNext; childOpIndex = this.opcodes[childOpIndex].opNext)
        {
            this.opExecute(childOpIndex, catCharIndex, catState);
            catCharIndex += catState[OP_MATCHED];
            catMatched += catState[OP_MATCHED];
            if(catState[OP_STATE] === APG_NOMATCH){break;}
        }
        state[OP_MATCHED] = catMatched;
        if(childOpIndex === op.opNext)
        {
            // success
            state[OP_STATE] = catMatched === 0 ? APG_EMPTY : APG_MATCH;
        }
        if(this.ast && state[OP_STATE] === APG_NOMATCH){this.ast.truncate(astLength);}
    };
    /*****************************************************************************/
    // the REPETITION operator
    this.opREP = function(opIndex, charIndex, state)
    {
        state[OP_STATE] = APG_NOMATCH;
        state[OP_MATCHED] = 0;
        var nextState, nextCharIndex, matchedCount, op, childOpIndex, astLength;
        nextState = [APG_ACTIVE, 0];
        nextCharIndex = charIndex;
        matchedCount = 0;
        op = this.opcodes[opIndex];
        childOpIndex = opIndex + 1;
        if(op.type !== REP){throw ['opREP: type ' + opcodeToString(op.type) +' not REP'];}
        astLength = (this.ast) ? this.ast.currentLength() : 0;
        while(true)
        {
            // always end on End of String
            if(nextCharIndex >= this.charEOS){break;}

            // execute the child opcode
            this.opExecute(childOpIndex, nextCharIndex, nextState);
            
            // end on nomatch
            if(nextState[OP_STATE] === APG_NOMATCH)
            {
                if(this.stats !== null){this.stats.backtrack(op);}
                break;
            }
            
            // always end on empty
            if(nextState[OP_STATE] === APG_EMPTY){break;}
            
            // increment for next repetition
            matchedCount+=1;
            state[OP_MATCHED] += nextState[OP_MATCHED];
            nextCharIndex += nextState[OP_MATCHED];
            
            // end on maxed out matches
            if(matchedCount === op.max){break;} 
        }
        
        // evaluate the match count
        if(state[OP_MATCHED] >= op.min)
        {
            // got a mathc
            state[OP_STATE] = (state[OP_MATCHED] === 0) ? APG_EMPTY : APG_MATCH;
        }
        else
        {
            // failed to meet minimum match requirement
            state[OP_STATE] = APG_NOMATCH;
            if(this.stats !== null){this.stats.backtrack(op);}
        }
        if(this.ast && state[OP_STATE] === APG_NOMATCH){this.ast.truncate(astLength);}
    };
    /*****************************************************************************/
    // the RULE NAME operator
    this.opRNM = function(opIndex, charIndex, state)
    {
        state[OP_STATE] = APG_ACTIVE;
        state[OP_MATCHED] = 0;
        var downIndex, astLength, op, rule, ruleOpIndex, ruleDefined;
        downIndex = 0;
        astLength = 0;
        op = this.opcodes[opIndex];
        if(op.type !== RNM){throw ['opRNM: type ' + opcodeToString(op.type) +' not RNM'];}

        rule = this.rules[op.ruleIndex];
        ruleOpIndex = rule.opcodeIndex;
        
        // AST
        ruleDefined = this.ast && this.ast.ruleDefined(op.ruleIndex); 
        if(ruleDefined)
        {
            astLength = this.ast.currentLength();
            downIndex = this.ast.down(op.ruleIndex);
        }
        
        // syntax call back
        if(this.syntax && this.syntax[op.ruleIndex])
        {
            this.syntax[op.ruleIndex](state, this.chars, charIndex, this.syntaxData);
        }
        
        if(state[OP_STATE] === APG_ACTIVE)
        {
            // execute the rule
            this.opExecute(ruleOpIndex, charIndex, state);
        }
        
        // syntax call back
        if(this.syntax && this.syntax[op.ruleIndex])
        {
            this.syntax[op.ruleIndex](state, this.chars, charIndex, this.syntaxData);
        }

        // AST
        if(ruleDefined)
        {
            if(state[OP_STATE] === APG_NOMATCH){this.ast.truncate(astLength);}
            else{this.ast.up(downIndex, charIndex, state[OP_MATCHED]);}
        }
    };
    /*****************************************************************************/
    // the SYNTACTIC PREDICATE operator
    this.opPRD = function(opIndex, charIndex, state)
    {
        state[OP_STATE] = APG_NOMATCH;
        state[OP_MATCHED] = 0;
        var op, prdState = [APG_ACTIVE, 0];
        op = this.opcodes[opIndex];
        if(op.type !== PRD){throw ['opPRD: type ' + opcodeToString(op.type) +' not PRD'];}

        // execute the child opcode
        if(this.ast){this.ast.inPRD+=1;}
        this.opExecute((opIndex + 1), charIndex, prdState);
        if(this.ast){this.ast.inPRD-=1;}
        
        // evaluate the result
        switch(prdState[OP_STATE])
        {
            case APG_EMPTY:
            case APG_MATCH:
            if(op.and)
            {
                // AND predicate
                state[OP_STATE] = APG_EMPTY;
            }
            else
            {
                // NOT predicate
                state[OP_STATE] = APG_NOMATCH;
                state[OP_MATCHED] = prdState[OP_MATCHED];
            }
            break;
                    
            case APG_NOMATCH:
            if(op.and)
            {
                // AND predicate
                state[OP_STATE] = APG_NOMATCH;
                state[OP_MATCHED] = prdState[OP_MATCHED];
            }
            else
            {
                // NOT predicate
                state[OP_STATE] = APG_EMPTY;
            }
            break;
            
            default:
            throw ['opPRD: invalid state ' + prdState[OP_STATE]];
        }
        // PRD always backtracks
        if(this.stats !== null){this.stats.backtrack(op);}
    };
    /*****************************************************************************/
    // the TERMINAL RANGE operator
    this.opTRG = function(opIndex, charIndex, state)
    {
        state[OP_STATE] = APG_NOMATCH;
        state[OP_MATCHED] = 0;
        var op = this.opcodes[opIndex];
        if(op.type !== TRG){throw ['opTRG: type ' + opcodeToString(op.type) +' not TRG'];}
        if(charIndex < this.charEOS)
        {
            if(op.min <= this.chars[charIndex] && this.chars[charIndex] <= op.max)
            {
                state[OP_STATE] = APG_MATCH;
                state[OP_MATCHED] = 1;
            }
        }
    };
    /*****************************************************************************/
    // the TERMINAL BINARY STRING operator
    this.opTBS= function(opIndex, charIndex, state)
    {
        state[OP_STATE] = APG_NOMATCH;
        state[OP_MATCHED] = 0;
        var i, op, len, stringIndex;
        op = this.opcodes[opIndex];
        if(op.type !== TBS){throw ['opTBS: type ' + opcodeToString(op.type) +' not TBS'];}
        len = op.length;
        stringIndex = op.stringIndex;
        if(len === 0){throw ['opTBS: string length cannot be 0'];}
        if((charIndex + len)  <= this.charEOS)
        {
            for(i=0; i < len; i+=1)
            {
                if(this.chars[charIndex + i] !== this.strings[stringIndex + i]){break;}
            }
            state[OP_MATCHED] = i;
            if(i === len){state[OP_STATE] = APG_MATCH;}
        }
    };
    /*****************************************************************************/
    // the TERMINAL LITERAL STRING operator
    this.opTLS = function(opIndex, charIndex, state)
    {
        state[OP_STATE] = APG_NOMATCH;
        state[OP_MATCHED] = 0;
        var i, code, strChar, len, stringIndex, op;
        op = this.opcodes[opIndex];
        if(op.type !== TLS){throw ['opTLS: type ' + opcodeToString(op.type) +' not TLS'];}
        len = op.length;
        stringIndex = op.stringIndex;
        if(len === 0)
        {
            state[OP_STATE] = APG_EMPTY;
        }
        else if((charIndex + len)  <= this.charEOS)
        {
            for(i=0; i < len; i+=1)
            {
                strChar = this.strings[stringIndex + i];
                if(strChar >= 65 && strChar <= 90){strChar += 32;}
                code = this.chars[charIndex + i];
                if(code >= 65 && code <= 90){code += 32;}
                if(code !== strChar){break;}
            }
            state[OP_MATCHED] = i;
            if(i === len){state[OP_STATE] = APG_MATCH;}
        }
    };
    /*****************************************************************************/
    // excecute any APG operator 
    this.opExecute = function(opIndex, charIndex, state)
    {
        var op, ret = true;
        op = this.opcodes[opIndex];
        
        // tree depth
        this.treeDepth+=1;

        // trace down
        state[OP_STATE] = APG_ACTIVE;
        state[OP_MATCHED] = 0;
        if(this.trace !== null){this.trace.traceDown(op, state[OP_STATE], charIndex, state[OP_MATCHED]);}
        
        switch(op.type)
        {
            case ALT:
            this.opALT(opIndex, charIndex, state);
            break;

            case CAT:
            this.opCAT(opIndex, charIndex, state);
            break;

            case RNM:
            this.opRNM(opIndex, charIndex, state);
            break;

            case REP:
            this.opREP(opIndex, charIndex, state);
            break;

            case PRD:
            this.opPRD(opIndex, charIndex, state);
            break;

            case TRG:
            this.opTRG(opIndex, charIndex, state);
            break;

            case TBS:
            this.opTBS(opIndex, charIndex, state);
            break;

            case TLS:
            this.opTLS(opIndex, charIndex, state);
            break;

            default:
            ret = false;
            break;
        }
        if((state[OP_STATE] !== APG_MATCH) && (state[OP_STATE] !== APG_NOMATCH) && (state[OP_STATE] !== APG_EMPTY))
            {throw ['opExecute: invalid state returned'];}
        
        // statistics up
        if(this.stats !== null){this.stats.collect(op, state);}
        
        // trace up
        if(this.trace !== null){this.trace.traceUp(op, state[OP_STATE], charIndex, state[OP_MATCHED]);}
        
        // tree depth
        this.treeDepth-=1;
        
        return ret;
    };
}

</script>
<script type="text/javascript">
/* apgUtilities.js */
/********************************************************************
  APG - an ABNF Parser Generator
  Copyright (C) 2009 Coast to Coast Research, Inc.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see
  <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
  or write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

	  author: Lowell Thomas
	          lowell@coasttocoastresearch.com
	          http://www.coasttocoastresearch.com

*********************************************************************/
/*global
isArray
*/
"use strict";
var ASCII_CR = 13;
var ASCII_LF = 10;
var ASCII_TAB = 9;
var ASCII_SPACE = 32;
var ASCII_MIN = 32;
var ASCII_MAX = 126;
var ASCII_LANGLE = 60;
var ASCII_RANGLE = 62;

/*****************************************************************************/
// convert a decimal integer to a hexidecimal string, eg. 16 -> 'FF'
// free download - source forgotten, apologies to the author
function dec2hex(d) {return d.toString(16).toUpperCase();}
/*****************************************************************************/
// convert a hexidecimal string to an integer, eg. 'FF' -> 16
// free download - source forgotten, apologies to the author
function hex2dec(h) {return parseInt(h,16);}
/*****************************************************************************/
// determine if an object is an array
// free download - source forgotten, apologies to the author
function isArray(a)
{
    return (Object.prototype.toString.apply(a) === '[object Array]');
}

/*****************************************************************************/
// a simple message log
// generates and displays an array of strings
function MsgLog()
{
    this.log = [];

    // returns the number of messages logged
    this.count = function(){return this.log.length;};

    // clears all logged messages
    this.clear = function(){this.log.length = 0;};

    // specialty function for logging error locations in grammar source
    // line - grammar line number
    // offset - location of the error, character offset into the grammar file
    // len - length of the (partially) matched phrase
    this.logLine = function(line, offset, len, msg)
    {
        if(typeof(msg) !== 'string'){msg = 'msg type: '+typeof(msg);}
        if(typeof(line) !== 'number'){line = false;}
        if(typeof(offset) !== 'number'){offset = false;}
        if(typeof(len) !== 'number'){len = false;}
        this.log.push([line, offset, len, ': '+msg]);
    };

    // add a message to the log
    this.logMsg = function(msg)
    {
        if(typeof(msg) !== 'string'){msg = 'msg type: '+typeof(msg);}
        this.log.push([false, false, false, msg]);
    };

    // HTML display the array of logged messages
    this.logDisplay = function(title)
    {
        var html = '';
        var i;
        if(typeof(title) === 'string'){html += title + '<br />';}
        if(this.log.length === 0)
        {
            html += '&lt;no messages&gt;<br />';
        }
        else
        {
            for(i = 0; i < this.log.length; i+=1)
            {
                var log = this.log[i];
                html += (i+1)+': ';
                if(!(log[0] === false)){html += ' line: '+log[0];}
                if(!(log[1] === false)){html += ' offset: '+log[1];}
                if(!(log[2] === false)){html += ' char: '+log[2];}

                html += log[3];
                html += '<br />';
            }
        }
        return html;
    };

    // table format HTML display the array of logged messages
    this.logDisplayTable = function(title)
    {
        var line;
        var offset;
        var len;
        var html = '<table class="log-table">';
        var i;
        if(typeof(title) === 'string'){html += '<caption class="log-caption">'+title + '</caption>';}
        if(this.log.length === 0)
        {
            html += '<tr><td>0</td><td>&lt;no messages&gt;</td></tr>';
        }
        else
        {
            for(i = 0; i < this.log.length; i+=1)
            {
                var log = this.log[i];
                if(log[0] === false){line = '-';}
                else{line = log[0];}
                if(log[1] === false){offset = '-';}
                else{offset = log[1];}
                if(log[2] === false){len = '-';}
                else{len = log[2];}
                if(i%2 === 0)
                {
                    html += '<tr class="even"><td>'+line+'</td><td>'+offset+'</td><td>'+len+'</td>';
                    html += '<td class="log-msg">'+log[3]+'</td></tr>';
                }
                else
                {
                    html += '<tr class="odd"><td>'+line+'</td><td>'+offset+'</td><td>'+len+'</td>';
                    html += '<td class="log-msg">'+log[3]+'</td></tr>';
                }
            }
        }
        html += '</table>';
        return html;
    };
}

/*****************************************************************************/
// assertion
// condition - if not true, a string execption is thrown
// msg - message string to be thrown as exception
function apgAssert(condition, msg)
{
    if(!condition)
    {
        var message = "apgAssert: failed: ";
        if(typeof(msg) === 'string'){message += msg;}
        throw [message];
    }
}

/*****************************************************************************/
// translate a substring (phrase) from ASCII character codes to a string
// chars - the full array of character codes
// phraseIndex - offset into chars to the first character of the phrase
// phraseLength - number of characters in the phrase
function charsToString(chars, phraseIndex, phraseLength)
{
    var string = '';
    if(isArray(chars))
    {
        var charIndex = (typeof(phraseIndex) === 'number' ) ? phraseIndex : 0;
        var charLength = (typeof(phraseLength) === 'number' ) ? phraseLength : chars.length;
        if(charLength > chars.length){charLength = chars.length;}
        var charEnd = charIndex + charLength;
        for(var i = charIndex; i < charEnd; i+=1)
        {
            if(chars[i]){string += String.fromCharCode(chars[i]);}
        }
    }
    return string;
}

/*****************************************************************************/
// translate a string to a normalized array of ASCII character codes
//   TAB  -> SPACE
//   CRLF -> LF
//   CR   -> LF
//   EOF  -> LF EOF (if missing)
// log - an instance of MsgLog();
// string - the string to translate
// chars = [] - the array to receive the ASCII character codes
function grammarToChars(log, string, chars)
{
    var ret = true;
    var lineNo = 0;
    var lineOffset = 0;
    var lineChar = 0;
    if(typeof(string) === 'string' && isArray(chars))
    {
        var charIndex = 0;
        var codeIndex = 0;
        chars.length = 0;
        while(charIndex < string.length)
        {
            var code = string.charCodeAt(charIndex);
            // convert TAB to SPACE
            if(code === ASCII_TAB){code = ASCII_SPACE;}
            else if(code === ASCII_CR)
            {
                // convert CRLF or CR to LF
                code = ASCII_LF;
                if(string.charCodeAt(charIndex+1) === ASCII_LF){charIndex+=1;}
            }
            else if(code !== ASCII_LF && (code < ASCII_MIN || code > ASCII_MAX) )
            {
                log.logLine(lineNo, lineOffset, lineChar, 'stringToChar: non-ASCII character found: '+code);
                ret = false;
            }
            chars[codeIndex] = code;
            charIndex+=1;
            codeIndex+=1;
            lineOffset+=1;
            lineChar+=1;
            if(code === ASCII_LF)
            {
                lineNo+=1;
                lineChar = 0;
            }
        }
        if(chars.length > 0 && chars[chars.length - 1] !== ASCII_LF)
        {
            // add missing line end
            //chars[chars.length] = ASCII_LF;
        }
        if(chars.length === 0)
        {
            log.logLine(0, 0, 0, 'input string may not be empty');
            ret = false;
        }
    }
    return ret;
}

/*****************************************************************************/
// converts ASCII-formatted binary characters to numbers, e.g. 0xff to 15
// log - an instance of a message log
// string - the ASCII formatted binary characters
// chars - an empty arrar for the translated numbers
function binaryStringToChars(log, string, chars)
{
    var ret = false, test;
    var stringIndex = 0;
    var charIndex = 0;
    var code, text, strlen;
    while(true)
    {
        if(typeof(string) !== 'string'){log.logMsg('apgUtilities: binaryStringToChars: string not type \'string\'');}
        if(!isArray(chars)){log.logMsg('apgUtilities: binaryStringToChars: chars not type \'array\'');}
        chars.length = 0;
        strlen = string.length;
        ret = true;
        while(stringIndex < strlen)
        {
            code = string.charCodeAt(stringIndex);
            if(code === 9 || code === 10 || code === 13 || code === 32)
            {
                // skip white space
                stringIndex+=1;
            }
            else
            {
                // get the next byte
                test = parseInt(string.substring(stringIndex));
                if(isNaN(test))
                {
                    log.logMsg('apgUtilities: binaryStringToChars: non-integer at: '+stringIndex);
                    ret = false;
                    break;
                }
                else if(test > 255)
                {
                    log.logMsg('apgUtilities: binaryStringToChars: integer > 255 at: '+stringIndex);
                    ret = false;
                    break;
                }
                else
                {
                    // get the byte code
                    chars[charIndex] = test;
                    charIndex+=1;

                    // skip over the parsed int
                    for(; stringIndex < strlen; stringIndex+=1)
                    {
                        code = string.charCodeAt(stringIndex);
                        if(!(code === 9 || code === 10 || code === 13 || code === 32)){continue;}
                        break;
                    }
                }
            }
        }

        break;
    }
    return ret;
}

/*****************************************************************************/
// converts a string to an array of character codes
// log - an instance of a message log object for error reporting
// string - the string to convert
// chars - an empty array to recieve the converted characters
function stringToChars(log, string, chars)
{
    var ret = false;
    if(typeof(string) === 'string' && isArray(chars))
    {
        var charIndex = 0;
        while(charIndex < string.length)
        {
            chars[charIndex] = string.charCodeAt(charIndex);
            charIndex+=1;
        }
        if(charIndex > 0){ret = true;}
    }
    return ret;
}

/*****************************************************************************/
// add line & character numbers before each line
// display line endings in colored text
function formatString(string)
{
    var ret = '';
    var line = '';
    var lineNo = 1;
    var lineLen = 0;
    var lineBeg = 0;
    var linePrint = false;
    var code;
    var i = 0;
    for(;i < string.length; i+=1)
    {
        if(linePrint)
        {
            // add the line prefix
            ret += lineNo+':['+lineBeg+']['+(lineLen)+'] '+line+'<br />';
            line = '';
            lineLen = 0;
            lineBeg = i;
            lineNo+=1;
            linePrint = false;
        }
        code = string.charCodeAt(i);
        if(code === ASCII_CR)
        {
            line += '<span class="non-ascii">CR</span>';
            if(string.charCodeAt(i+1) !== ASCII_LF){linePrint = true;}
        }
        else if(code === ASCII_LF)
        {
            line += '<span class="non-ascii">LF</span>';
            linePrint = true;
        }
        else if(code < ASCII_MIN || code > ASCII_MAX){line += '<span class="non-ascii">x'+dec2hex(code)+'</span>';}
        else{line += string.charAt(i);}
        lineLen+=1;
    }
    if(lineLen > 0)
    {
        ret += lineNo+':['+lineBeg+']['+(lineLen)+'] '+line+'<br />';
    }
    return ret;
}

/*****************************************************************************/
// formats an array of character codes for HTML display of the string
// chars - the array of character codes
// returns HTML
function formatChars(chars)
{
    var ret = '';
    var line = '';
    var lineNo = 1;
    var lineLen = 0;
    var lineBeg = 0;
    var linePrint = false;
    var code;
    var i = 0;
    for(;i < chars.length; i+=1)
    {
        if(linePrint)
        {
            // add the line prefix
            ret += lineNo+':['+lineBeg+']['+(lineLen)+'] '+line+'<br />';
            line = '';
            lineLen = 0;
            lineBeg = i;
            lineNo+=1;
            linePrint = false;
        }
        code = chars[i];
        if(code === ASCII_CR)
        {
            line += '<span class="non-ascii">CR</span>';
            if(chars[i+1] !== ASCII_LF){linePrint = true;}
        }
        else if(code === ASCII_LF)
        {
            line += '<span class="non-ascii">LF</span>';
            linePrint = true;
        }
        else if(code < ASCII_MIN || code > ASCII_MAX){line += '<span class="non-ascii">x'+dec2hex(code)+'</span>';}
        else{line += String.fromCharCode(chars[i]);}
        lineLen+=1;
    }
    if(lineLen > 0)
    {
        ret += lineNo+':['+lineBeg+']['+(lineLen)+'] '+line+'<br />';
    }
    return ret;
}

/*****************************************************************************/
// returns true if the first 1000 array values are ASCII character codes
// chars - an array of integers
this.charsAreAscii = function(chars)
{
    var count = 0;
    var max = 1000;
    var len = (chars.length > max) ? max : chars.length;
    for(var i = 0; i < len; i+=1)
    {
        if(chars[i] === 9){count+=1;}
        else if(chars[i] === 10){count+=1;}
        else if(chars[i] === 13){count+=1;}
        else if(chars[i] >= 32 && chars[i] <= 127){count+=1;}
    }
    return (((count * 100)/len) >= 25);
};

/*****************************************************************************/
// returns true if the array of character codes represents an ASCII-formatted string of binary values
// chars - the array of character codes
function inputIsBinary(chars)
{
    var ret = true;
    var isWhite, value, string;
    var count = 0;
    var i = 0;
    var len = chars.length;
    var max = 100;
    while(i < len && count < max)
    {
        // skip white space
        isWhite = true;
        while(i < len && isWhite)
        {
            if(chars[i] === 9 || chars[i] === 10 || chars[i] === 13 || chars[i] === 32){isWhite = true;i+=1;}
            else{isWhite = false;}
        }
        if(i === len){break;}

        // get next binary value
        string = '';
        isWhite = false;
        while(i < len && !isWhite)
        {
            if(chars[i] === 9 || chars[i] === 10 || chars[i] === 13 || chars[i] === 32){isWhite = true;}
            else{string += String.fromCharCode(chars[i]);i+=1;}
        }

        value = parseInt(string, 10);
        if(isNaN(value)){ret = false;break;}
        else{count+=1;}
    }
    if(count === 0){ret = false;}
    return ret;
}

/*****************************************************************************/
// formats an array of character codes to an HTML table of hexidecimal format
// chars - the array of character codes
function tableCharsHex(chars)
{
        var html = '';
        var htmlHex = '';
        var htmlAscii = '';
        var htmlCount = '';
        var hexChar;
        var spanEven = '<span class="ast-highlight-even">';
        var spanOdd = '<span class="ast-highlight-odd">';
        var emptyHex = '<span class="ast-empty">00</span>';
        var emptyAscii = '<span class="ast-empty">&epsilon;</span>';
        var count = 0;
        var matchLen = 24;
        htmlCount += '0:<br />';
        for(var i = 0; i < chars.length; i+=1)
        {
            if(chars[i] < 32 || chars[i] > 126){htmlAscii += '&#46;';}
            else if(chars[i] === 32){htmlAscii += '&nbsp;';}
            else{htmlAscii += '&#'+chars[i];}
            hexChar = chars[i].toString(16).toUpperCase();
            if(hexChar.length === 1){htmlHex += '0' + hexChar;}
            else{htmlHex += hexChar;}
            count+=1;
            if(count === matchLen)
            {
                htmlHex += '<br />';
                htmlAscii += '<br />';
                htmlCount += i+':<br />';
                count = 0;
            }
            else
            {
                if(count%4 === 0){htmlHex += '&nbsp;';}
            }

        }
        html += '<pre><table class="phrase-table"><tr>';
        html += '<td class="right">'+htmlCount+'</td>';
        html += '<td>'+htmlHex+'</td>';
        html += '<td>'+htmlAscii+'</td>';
        html += '</tr></table></pre>';
        return html;
}

/*****************************************************************************/
// formats an array of character codes into an HTML table of ASCII lines
// chars - the array of character codes
function tableChars(chars)
{
    var html = '';
    var maxLineLen = 0;
    var line = '';
    var lineNo = 1;
    var lineLen = 0;
    var lineBeg = 0;
    var linePrint = false;
    var lineBreak = 128;
    var linePrintLen = 0;
    var lineContinue = false;
    var code;
    var i = 0;
    html += '<tr>';
    html += '<td>(a)</td>';
    html += '<td>(b)</td>';
    html += '<td>(c)</td>';
    html += '<td class="log-msg">&nbsp;</td>';
    html += '</tr>';
    for(;i < chars.length; i+=1)
    {
        if(linePrint)
        {
            if(lineNo%2 === 0){html += '<tr class="odd">';}
            else{html += '<tr class="even">';}
            linePrintLen += lineLen;
            if(lineContinue)
            {
                html += '<td>'+lineNo+':</td>';
                html += '<td>'+lineBeg+':</td>';
                html += '<td>&ndash;&gt;:</td>';
                html += '<td class="log-msg">'+line+'</td></tr>';
            }
            else
            {
                html += '<td>'+lineNo+':</td>';
                html += '<td>'+lineBeg+':</td>';
                html += '<td>'+linePrintLen+':</td>';
                html += '<td class="log-msg">'+line+'</td></tr>';
                lineNo+=1;
                linePrintLen = 0;
            }
            line = '';
            if(maxLineLen < lineLen){maxLineLen = lineLen;}
            lineLen = 0;
            lineBeg = i;
            linePrint = false;
            lineContinue = false;
        }
        code = chars[i];
        if(code === ASCII_CR)
        {
            line += '<span class="non-ascii">CR</span>';
            lineLen+=2;
            if(chars[i+1] !== ASCII_LF){linePrint = true;}
        }
        else if(code === ASCII_LF)
        {
            line += '<span class="non-ascii">LF</span>';
            lineLen+=2;
            linePrint = true;
        }
        else if(code < ASCII_MIN || code > ASCII_MAX){line += '<span class="non-ascii">x'+dec2hex(code)+'</span>';lineLen+=3;}
        else if(chars[i] === 32){line += '&nbsp;';lineLen+=1;}
        else{line += '&#'+chars[i];lineLen+=1;}
        if(lineLen >= lineBreak)
        {
            linePrint = true;
            lineContinue = true;
        }
    }
    if(lineLen > 0)
    {
        linePrintLen += lineLen;
        if(lineNo%2 === 0){html += '<tr class="odd">';}
        else{html += '<tr class="even">';}
        html += '<td>'+lineNo+':</td>';
        html += '<td>'+lineBeg+':</td>';
        html += '<td>'+linePrintLen+':</td>';
        html += '<td class="log-msg">'+line+'</td></tr>';
    }
    html += '<tr>';
    html += '<td>(a)</td>';
    html += '<td>(b)</td>';
    html += '<td>(c)</td>';
    html += '<td class="log-msg">&nbsp;</td>';
    html += '</tr>';
    html = '<table width="'+(maxLineLen*10)+'" class="log-table">' + html + '</table>';
    html += '<p class="log-msg">';
    html += '(a) - line number<br />';
    html += '(b) - first character of line (or line fragment<sup>*</sup>)<br />';
    html += '(c) - line length (or "&ndash;&gt;" for line fragment<sup>*</sup>)<br /><br />';
    html += '<sup>*</sup>Lines longer than '+lineBreak+' are displayed as multiple printed fragments<br />';
    html += '</p>';
    return html;
}

/*****************************************************************************/
// convert a true/false value  to a string
function trueToString(value)
{
    if(value){return 'TRUE';}
    else{return 'FALSE';}
}

/*****************************************************************************/
// convert an APG state to a string
function stateToString(state)
{
    var ret = 'unknown';
    switch(state)
    {
        case APG_ACTIVE:
        ret = 'ACTIVE';
        break;

        case APG_EMPTY:
        ret = 'EMPTY';
        break;

        case APG_NOMATCH:
        ret = 'NOMATCH';
        break;

        case APG_MATCH:
        ret = 'MATCH';
        break;

        case APG_PRE:
        ret = 'SEMANTIC PRE-BRANCH';
        break;

        case APG_POST:
        ret = 'SEMANTIC POST-BRANCH';
        break;
    }
    return ret;
}

/*****************************************************************************/
// convert APG opcode type to a string
function opcodeToString(type)
{
    var ret = 'unknown';
    switch(type)
    {
        case ALT:
        ret = 'ALT';
        break;

        case CAT:
        ret = 'CAT';
        break;

        case RNM:
        ret = 'RNM';
        break;

        case PRD:
        ret = 'PRD';
        break;

        case REP:
        ret = 'REP';
        break;

        case TRG:
        ret = 'TRG';
        break;

        case TBS:
        ret = 'TBS';
        break;

        case TLS:
        ret = 'TLS';
        break;
    }
    return ret;
}

/*****************************************************************************/
// universal evaluation of a thrown object
function objEval(obj)
{
    var ret = 'objEval: ';
    for(var x in obj)
    {
        ret += x + ": " + obj[x];
        ret += '<br />\n';
    }
    return ret;
}

/*****************************************************************************/
// selects all text in an HTML element with id="testarea"
function SelecText(testarea)
{
    window.document.getElementById("testarea").select();
}

/*****************************************************************************/
/**
* source: http://www.openjs.com/scripts/others/dump_function_php_print_r.php
* Function : dump()
* Arguments: The data - array,hash(associative array),object
*    The level - OPTIONAL
* Returns  : The textual representation of the array.
* This function was inspired by the print_r function of PHP.
* This will accept some data as the argument and return a
* text that will be a more readable version of the
* array/hash/object that is given.
*/
function dump(arr,level) {
var dumped_text = "";
if(!level) {level = 0;}

//The padding given at the beginning of the line.
var level_padding = "";
for(var j=0;j<level;j+=1) {level_padding += "  ";}

if(typeof(arr) === 'object') { //Array/Hashes/Objects
 for(var item in arr) {
  var value = arr[item];

  if(typeof(value) === 'object') { //If it is an array,
   dumped_text += level_padding + "'" + item + "' ...\n";
   dumped_text += dump(value,level+1);
  } else {
   dumped_text += level_padding + "'" + item + "' => \"" + value + "\"\n";
  }
 }
} else { //Stings/Chars/Numbers etc.
 dumped_text = "===>"+arr+"<===("+typeof(arr)+")";
}
return dumped_text;
}

/*****************************************************************************/
// from: http://elmicoxcodes.blogspot.com/2007/06/htmlentities-and-arraysearch-in.html
function htmlentities(texto){
    //by Micox - elmicoxcodes.blogspot.com - www.ievolutionweb.com
    var i,carac,letra,novo='';
    for(i=0;i<texto.length;i++){
        carac = texto[i].charCodeAt(0);
        if( (carac > 47 && carac < 58) || (carac > 62 && carac < 127) ){
            //se for numero ou letra normal
            novo += texto[i];
        }else{
            novo += "&#" + carac + ";";
        }
    }
    return novo;
}

/*****************************************************************************/
// clumsy replacement of special characters with HTML entities
// chars - array of character codes
function htmlspecialchars(chars)
{
    var i, c, html = '';
    for(i = 0; i < chars.length; i++)
    {
        c = chars.charAt(i);
        switch(c)
        {
            case '<': html += '&lt;';break;
            case '>': html += '&gt;';break;
            case '&': html += '&amp;';break;
            case '"': html += '&quot;';break;
            case '\'': html += '&#039;';break;
            default: html += c;break;
        }
    }
    return html;
}

/*****************************************************************************/
// circular buffer
// used by Trace to keep track of where the last N records are in a circular
// buffer used to store at most N trace information records
function Circular()
{
    this.lastIndex = 0;
    this.nextIndex = 0;
    this.bufferMax = 0;
    this.itemCount = 0;
    this.bufferSize = 0;

    // initialize the circular buffer for record collection
    this.initCollection = function(size)
    {
        this.bufferSize = size;
        this.lastIndex = 0;
        this.itemCount = 0;
        this.nextIndex = 0;
        this.sequential = true;
    };

    // called once for each record collected
    this.collect = function()
    {
        if(this.lastIndex >= this.bufferSize){this.lastIndex = 0;this.sequential = false;}
        var ret = this.lastIndex;
        this.lastIndex += 1;
        if(this.lastIndex > this.itemCount){this.itemCount = this.lastIndex;}
        return ret;
    };

    // returns the bufferSize (N))
    this.size = function(){return this.bufferSize;}

    // returns the total number of records saved
    this.items = function(){return this.itemCount;}

    // returns true if the number of records <= the buffer size
    // e.g. the records read top to bottom in the buffer
    this.isSequential = function(){return this.sequential;}

    // initialize a replay of the record numbers saved in the buffer
    this.initReplay = function()
    {
        if(this.isSequential()){this.nextIndex = 0;}
        else{this.nextIndex = this.lastIndex;}
    };

    // on each call returns the buffer location of the next saved record
    // records are returned in ascending order
    // e.g. if last 100 of 1000 records were save, replay() would
    // successively return buffer positions corresponding to records 100, 101, ... 198, 199
    this.replay = function()
    {
        var ret;
        if(this.nextIndex >= this.bufferSize){this.nextIndex = 0;}
        ret = this.nextIndex;
        this.nextIndex += 1;
        return ret;
    };

    // initialize the replay for reverse order or descending
    this.initReverse = function()
    {
        if(this.isSequential()){this.nextIndex = this.itemCount - 1;}
        else{this.nextIndex = this.lastIndex - 1;}
    };

    // returns records in opposite order of replay()
    this.reverse = function()
    {
        var ret;
        if(this.nextIndex < 0){this.nextIndex = this.itemCount - 1;if(this.nextIndex < 0){return 0;}}
        ret = this.nextIndex;
        this.nextIndex -= 1;
        return ret;
    };
}

</script>
<script type="text/javascript">
/* apgTrace.js */
/********************************************************************
  APG - an ABNF Parser Generator
  Copyright (C) 2009 Coast to Coast Research, Inc.
 
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see
  <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
  or write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
	  author: Lowell Thomas
	          lowell@coasttocoastresearch.com
	          http://www.coasttocoastresearch.com

*********************************************************************/
/*global
ALT, CAT, REP, PRD, TRG, TBS, TLS, RNM, APG_SEM_OK, APG_PRE, APG_POST,
OP_STATE, APG_MATCH, APG_NOMATCH, APG_EMPTY, APG_ACTIVE,
isArray, stateToString, opcodeToString, apgAssert, charsToString, charsAreAscii,
dec2hex
*/
"use strict";
// trace configuration defaults
var DEFAULT_TRACE_ON        = true;
var DEFAULT_TRACE_DISPLAY   = 'auto';
var DEFAULT_MAX_SAVED       = 100000;
var DEFAULT_MAX_DISPLAYED   = 1000;
//var DEFAULT_LINE_RANGE      = 'firstN';
var DEFAULT_LINE_RANGE      = 'lastN';
//var DEFAULT_LINE_RANGE      = 'record-range';

/*CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC*/
// TRACE CLASS
function Trace()
{
    /*****************************************************************************/
    /*  FILTERS */
    //  tracing is filtered according to info in the parse filter
    //  display of the filtered records is again filtered according to the info in the display filter
    /*****************************************************************************/
    
    /*****************************************************************************/
    // used to set default values for the filters
    // filter - an array to receive the filter data
    // count - the value to use for "line-count"
    this.setDefaultFilter = function(filter, count)
    {
        filter.trace = DEFAULT_TRACE_ON;
        filter.display = DEFAULT_TRACE_DISPLAY;
        filter['max-saved'] = DEFAULT_MAX_SAVED;
        filter['max-displayed'] = DEFAULT_MAX_DISPLAYED;
        filter['line-range'] = DEFAULT_LINE_RANGE;
        filter['first-record'] = 0;
        filter['line-count'] = count;
        filter['last-record'] = 0;
        filter.match = true;
        filter.nomatch = true;
        filter.empty = true;
        filter.ops = [];
        filter.ops[ALT] = false;
        filter.ops[CAT] = false;
        filter.ops[REP] = false;
        filter.ops[PRD] = false;
        filter.ops[TRG] = false;
        filter.ops[TBS] = false;
        filter.ops[TLS] = false;
        filter.rules = [];
        filter['rule-map'] = [];
        filter['rule-names'] = [];
        for(var i = 0; i <this.rules.length; i+=1)
        {
            filter.rules[i] = true;
            filter['rule-names'][i] = this.rules[i].rule;
            filter['rule-map'][this.rules[i].rule] = i;
        }
    };
    
    /*****************************************************************************/
    // sets the default parse filter
    this.setDefaultParseFilter = function()
    {
        this.setDefaultFilter(this.parseFilter, DEFAULT_MAX_SAVED);
    }
    
    /*****************************************************************************/
    // sets the default display filter
    this.setDefaultDisplayFilter = function()
    {
        this.setDefaultFilter(this.displayFilter, DEFAULT_MAX_DISPLAYED);
    };

    /*****************************************************************************/
    // during debugging, changes may be made to the grammar, changing the number
    // and names of the rule names
    // reconciliation will keep the filter values for the rule names that have not changed
    // and set default values for the new rule names
    this.reconcileRules = function(rules, filter)
    {
        var tempRules = [];
        var tempRuleMap = [];
        var tempRuleNames  =[];
        var i, j, ruleName;
        for(i = 0; i < this.rules.length; i+=1)
        {
            ruleName = this.rules[i].rule;
            j = filter['rule-map'][ruleName]; 
            if(j === undefined){tempRules[i] = true;}
            else{tempRules[i] = filter.rules[j];}
            tempRuleMap[ruleName] = i;
            tempRuleNames[i] = ruleName;
        }
        filter.rules = tempRules;
        filter['rule-map'] = tempRuleMap;
        filter['rule-names'] = tempRuleNames;
    };
    
    /*****************************************************************************/
    // disables any relevant parse filter options that are false
    // operators whose records were not saved during parsing must be disabled
    // when the user is choosing the operators to display
    this.maskDisplayFilter = function()
    {
        this.displayFilter.ops[ALT] = this.parseFilter.ops[ALT] ? this.parseFilter.ops[ALT]: undefined;
        this.displayFilter.ops[CAT] = this.parseFilter.ops[CAT] ? this.parseFilter.ops[CAT]: undefined;
        this.displayFilter.ops[REP] = this.parseFilter.ops[REP] ? this.parseFilter.ops[REP]: undefined;
        this.displayFilter.ops[PRD] = this.parseFilter.ops[PRD] ? this.parseFilter.ops[PRD]: undefined;
        this.displayFilter.ops[TRG] = this.parseFilter.ops[TRG] ? this.parseFilter.ops[TRG]: undefined;
        this.displayFilter.ops[TBS] = this.parseFilter.ops[TBS] ? this.parseFilter.ops[TBS]: undefined;
        this.displayFilter.ops[TLS] = this.parseFilter.ops[TLS] ? this.parseFilter.ops[TLS]: undefined;
        for(var i = 0; i <this.rules.length; i+=1)
        {
            this.displayFilter.rules[i] = this.parseFilter.rules[i] ? this.parseFilter.rules[i]: undefined;
        }
    };
    
    /*****************************************************************************/
    // sets one value in a filter
    // filter - the filter to modify
    // option - the filter array element to modify
    // value - the new value to set for the filter option
    // ruleIndex - only used for the rule option, it is the index of the rule to set
    this.setFilter = function(filter, option, value, ruleIndex)
    {
        switch(option)
        {
            case 'trace':
            filter.trace = value;
            break;
            case 'max-saved':
            filter['max-saved'] = value;
            break;
            case 'display':
            filter.display = value;
            break;
            case 'max-displayed':
            filter['max-displayed'] = value;
            break;
            case 'line-range':
            filter['line-range'] = value;
            break;
            case 'first-record':
            filter['first-record'] = value;
            break;
            case 'line-count':
            filter['line-count'] = value;
            break;
            case 'last-record':
            filter['last-record'] = value;
            break;
            case 'match':
            filter.match = value;
            break;
            case 'nomatch':
            filter.nomatch = value;
            break;
            case 'empty':
            filter.empty = value;
            break;
            case 'alt':
            filter.ops[ALT] = value;
            break;
            case 'cat':
            filter.ops[CAT] = value;
            break;
            case 'rep':
            filter.ops[REP] = value;
            break;
            case 'prd':
            filter.ops[PRD] = value;
            break;
            case 'trg':
            filter.ops[TRG] = value;
            break;
            case 'tbs':
            filter.ops[TBS] = value;
            break;
            case 'tls':
            filter.ops[TLS] = value;
            break;
            case 'rule':
            filter.rules[ruleIndex] = value;
            break;
        }
    };

    /*****************************************************************************/
    // resets the parse filter to its default values
    this.resetParseFilter = function()
    {
        var temp = [];
        this.setDefaultFilter(temp, DEFAULT_MAX_SAVED);
        temp.rules = [];
        temp['rule-map'] = [];
        temp['rule-names'] = [];
        if(this.rules && this.parseFilter.rules)
        {
            for(var i = 0; i < this.rules.length; i+=1)
            {
                var ruleName = this.rules[i].rule;
                temp.rules[i] = true;
                temp['rule-map'][ruleName] = i;
                temp['rule-names'][i] = ruleName;
            }
        }
        this.parseFilter = temp;
    };

    /*****************************************************************************/
    // resets the display filter to its default values
    this.resetDisplayFilter = function()
    {
        var temp = [];
        this.setDefaultFilter(temp, DEFAULT_MAX_DISPLAYED);
        temp.ops[ALT] = this.displayFilter.ops[ALT] === undefined ? undefined: this.displayFilter.ops[ALT]; 
        temp.ops[CAT] = this.displayFilter.ops[CAT] === undefined ? undefined: this.displayFilter.ops[CAT]; 
        temp.ops[REP] = this.displayFilter.ops[REP] === undefined ? undefined: this.displayFilter.ops[REP]; 
        temp.ops[PRD] = this.displayFilter.ops[PRD] === undefined ? undefined: this.displayFilter.ops[PRD]; 
        temp.ops[TRG] = this.displayFilter.ops[TRG] === undefined ? undefined: this.displayFilter.ops[TRG]; 
        temp.ops[TBS] = this.displayFilter.ops[TBS] === undefined ? undefined: this.displayFilter.ops[TBS]; 
        temp.ops[TLS] = this.displayFilter.ops[TLS] === undefined ? undefined: this.displayFilter.ops[TLS]; 
        temp.rules = [];
        temp['rule-map'] = [];
        temp['rule-names'] = [];
        if(this.rules && this.parseFilter.rules)
        {
            for(var i = 0; i < this.rules.length; i+=1)
            {
                var ruleName = this.rules[i].rule;
                temp.rules[i] = this.displayFilter.rules[i] === undefined ? undefined: true;
                temp['rule-map'][ruleName] = i;
                temp['rule-names'][i] = ruleName;
            }
        }
        this.displayFilter = temp;
    };

    /*****************************************************************************/
    // debugging use only
    // returns an HTML-formatted dump of a filter
    this.dumpFilter = function(filter)
    {
        var html = '';
        html += '<br />';
        html += 'Trace.dumpFilter:';
        html += '<br />display: '+filter.display;
        html += '<br />max-saved: '+filter['max-saved'];
        html += '<br />max-displayed: '+filter['max-displayed'];
        html += '<br />line-range: '+filter['line-range'];
        html += '<br />first-record: '+filter['first-record'];
        html += '<br />line-count: '+filter['line-count'];
        html += '<br />last-record: '+filter['last-record'];
        html += '<br />match: '+filter.match;
        html += '<br />nomatch: '+filter.nomatch;
        html += '<br />empty: '+filter.empty;
        html += '<br />alt: '+filter.ops[ALT];
        html += '<br />cat: '+filter.ops[CAT];
        html += '<br />rep: '+filter.ops[REP];
        html += '<br />prd: '+filter.ops[PRD];
        html += '<br />trg: '+filter.ops[TRG];
        html += '<br />tbs: '+filter.ops[TBS];
        html += '<br />tls: '+filter.ops[TLS];
        for(var i = 0; i < filter.rules.length; i+=1)
        {
            html += '<br />rule['+i+']: '+filter['rule-names'][i]+': '+filter.rules[i];
        }
        return html;
    };

    /*****************************************************************************/
    /*  TRACE */
    /*****************************************************************************/

    /*****************************************************************************/
    // saves a single trace record during downward traversal of the syntax tree
    // op - the opcode being traversed
    // state the current state of the node
    // offset - index of the phrase being parsed
    // length - length of the matched phrase
    this.traceDown = function(op, state, offset, length)
    {
        var circularSaved;
        if(this.parseFilter.trace)
        {
            // filter on operator selection
            if(this.parseOpFilter(op))
            {
                this.depthStack[this.depth] = [];
                this.depthStack[this.depth].filteredLine = this.opFilteredLines;
                this.depthStack[this.depth].savedLine = undefined;
                this.depthStack[this.depth].savedSequenceNumber = undefined;
                if(this.firstOpFiltered === -1){this.firstOpFiltered = this.unfilteredLines;}
                
                // filter on line selection
                if(this.parseLineFilter(this.unfilteredLines, this.savedLines, this.parseFilter))
                {
                    if(this.firstSaved === -1){this.firstSaved = this.unfilteredLines;}
                    circularSaved = this.parseCircular.collect();
                    this.depthStack[this.depth].savedLine = circularSaved;
                    this.depthStack[this.depth].savedSequenceNumber = this.unfilteredLines;
                    this.lines[circularSaved] = [];
                    this.lines[circularSaved].dir = 'down';
                    this.lines[circularSaved].depth = this.depth;
                    this.lines[circularSaved].sequenceNumber = this.unfilteredLines;
                    this.lines[circularSaved].otherSequenceNumber = undefined;
                    this.lines[circularSaved].thisSavedLine = circularSaved;
                    this.lines[circularSaved].otherSavedLine = undefined;
                    this.lines[circularSaved].opType = op.type;
                    this.lines[circularSaved].state = state;
                    this.lines[circularSaved].offset = offset;
                    this.lines[circularSaved].length = length;
                    if(op.type === RNM){this.lines[circularSaved].ruleIndex = op.ruleIndex;}
                    this.savedLines+=1;
                    this.lastSaved = this.unfilteredLines;
                }
                this.opFilteredLines+=1;
                this.depth+=1;
                this.lastOpFiltered = this.unfilteredLines;
            }
            this.unfilteredLines+=1;
        }
    };

    /*****************************************************************************/
    // saves a single trace record during upward traversal of the syntax tree
    // op - the opcode being traversed
    // state the current state of the node
    // offset - index of the phrase being parsed
    // length - length of the matched phrase
    this.traceUp = function(op, state, offset, length)
    {
        var circularSaved;
        if(this.parseFilter.trace)
        {
            // filter on operator selection
            if(this.parseOpFilter(op))
            {
                this.depth-=1;
                var otherFilteredLine = this.depthStack[this.depth].filteredLine;
                var otherSavedLine = this.depthStack[this.depth].savedLine;
                var otherSequenceNumber = this.depthStack[this.depth].savedSequenceNumber;
                if(this.firstOpFiltered === -1){this.firstOpFiltered = this.unfilteredLines;}

                // filter on line selection
                if(this.parseLineFilter(this.unfilteredLines, this.savedLines, this.parseFilter))
                {
                    if(this.firstSaved === -1){this.firstSaved = this.unfilteredLines;}
                    circularSaved = this.parseCircular.collect();
                    if(otherSavedLine !== undefined)
                    {
                        this.lines[otherSavedLine].otherSavedLine = circularSaved;
                        this.lines[otherSavedLine].length = length;
                        this.lines[otherSavedLine].otherSequenceNumber = this.unfilteredLines;
                    }
                    this.lines[circularSaved] = [];
                    this.lines[circularSaved].dir = 'up';
                    this.lines[circularSaved].depth = this.depth;
                    this.lines[circularSaved].sequenceNumber = this.unfilteredLines;
                    this.lines[circularSaved].otherSequenceNumber = otherSequenceNumber;
                    this.lines[circularSaved].thisSavedLine = circularSaved;
                    this.lines[circularSaved].otherSavedLine = otherSavedLine;
                    this.lines[circularSaved].opType = op.type;
                    this.lines[circularSaved].state = state;
                    this.lines[circularSaved].offset = offset;
                    this.lines[circularSaved].length = length;
                    if(op.type === RNM){this.lines[circularSaved].ruleIndex = op.ruleIndex;}
                    this.savedLines+=1;
                    this.lastSaved = this.unfilteredLines;
                }
                this.opFilteredLines+=1;
                this.lastOpFiltered = this.unfilteredLines;
            }
            this.unfilteredLines+=1;
        }
    };
    
    /*****************************************************************************/
    // filters on operators type according to the parse filter parameters
    this.parseOpFilter = function(op)
    {
        // check the operator
        var opMatch = false;
        if(op.type === RNM && this.parseFilter.rules[op.ruleIndex]){opMatch = true;}
        else if(this.parseFilter.ops[op.type]){opMatch = true;}
        return opMatch;
    };
    
    /*****************************************************************************/
    // filters the line range selection according to the parse filter parameters
    this.parseLineFilter = function(thisRecord, thisLine, filter)
    {
        var ret = false;
        var maxLines;
        if((thisRecord >= filter['first-record']))
        {
            switch(filter['line-range'])
            {
                case 'firstN':
                if((thisLine < this.linesMax)){ret = true;} 
                break;
                case 'record-range':
                if((thisRecord <= filter['last-record'] && thisLine < filter['max-saved'])){ret = true;} 
                break;
                case 'lastN':
                // allow all lines
                ret = true;
                break;
                default:
                throw ['Trace: parseLineFilter: unrecognized filter[\'line-range\']: '+filter['line-range']];
                break;
            }
        }             
        return ret;
    };
    
    /*****************************************************************************/
    /*  DISPLAY */
    /*****************************************************************************/
    /*****************************************************************************/
    // returns an HTML display of the saved and filtered trace records
    this.display = function()
    { 
        if(this.parseFilter['line-range'] == 'lastN' && !this.parseCircularReversed)
        {
            this.parseReverse();
            this.parseCircularReversed = true;
        }
        this.filterSavedLines();
        return this.displayFiltered();
    };
    
    /*****************************************************************************/
    // re-compute the other sequence number using a reverse scan of the saved lines
    // required after saving only the last N records
    this.parseReverse = function()
    {
        this.parseCircular.initReverse();
        this.depthStack.length = 0;
        var i, max, j, depth, line, otherLine;
        max = this.parseCircular.items();
        depth = 0;
        for(i = 0; i < max; i+=1)
        {
            j = this.parseCircular.reverse();
            line = this.lines[j];
            if(line.dir == 'up')
            {
                this.depthStack[depth] = [];
                this.depthStack[depth].depthLine = j;
                line.otherSequenceNumber = undefined;
                depth += 1;
            }
            else
            {
                depth -= 1;
                otherLine = this.depthStack[depth].depthLine;
                line.otherSequenceNumber = this.lines[otherLine].sequenceNumber;
                this.lines[otherLine].otherSequenceNumber = line.sequenceNumber; 
            }
        }
    }
    
    /*****************************************************************************/
    // scans all saved trace records and filters them according to the display filter
    this.filterSavedLines = function()
    {
        var i, j;
        var line, otherLine;
        this.initDisplay();
        
        // all saved lines
        var max = this.parseCircular.items();           
        this.parseCircular.initReplay();
        for(i = 0; i < max; i+=1)
        {
            j = this.parseCircular.replay();
            line = this.lines[j];
            line.thisFilteredLine = undefined;
            
            // filter display lines on operator and state
            if(this.displayFilterOp(line) && this.displayFilterState(line))
            {
                if(this.firstOpDisplayed === -1){this.firstOpDisplayed = line.sequenceNumber;}
                
                // filter display lines on line range
                if(this.displayLineFilter(this.displayedLines, line, this.displayFilter))
                {
                    if(this.firstDisplayed === -1){this.firstDisplayed = line.sequenceNumber;}
                    this.dLines[this.displayCircular.collect()] = j;
                    line.thisFilteredLine = this.displayedLines;
                    if(line.dir === 'down'){line.otherFilteredLine = undefined;}
                    else
                    {
                        if(line.otherSavedLine !== undefined)
                        {
                            otherLine = this.lines[line.otherSavedLine];
                            otherLine.otherFilteredLine = this.displayedLines;
                            line.otherFilteredLine = otherLine.thisFilteredLine;
                        }
                    }
                    this.displayedLines+=1;
                    this.lastDisplayed = line.sequenceNumber;
                }
                this.opDisplayedLines+=1;
                this.lastOpDisplayed = line.sequenceNumber;
            }
        }
    };
    
    /*****************************************************************************/
    // returns an HTML-tabular format of the filtered records
    this.displayFiltered = function()
    {
        var modeDisplay;
        if(this.displayFilter.display === 'ascii'){modeDisplay = this.displayAscii;}
        else if(this.displayFilter.display === 'hex'){modeDisplay = this.displayHex;}
        else
        {
            if(charsAreAscii(this.chars)){modeDisplay = this.displayAscii;}
            else{modeDisplay = this.displayHex;}
        }
        var parseStats = '';
        parseStats += '<table class="log-table">';
        parseStats += '<caption>PARSER FILTER</caption>';
        parseStats += '<tr><td>max saved records:&nbsp;</td><td class="log-msg">'+this.parseFilter['max-saved']+'</td></tr>';
        parseStats += '<tr><td>unfiltered records:&nbsp;</td><td class="log-msg">'+this.unfilteredLines+'</td></tr>';
        parseStats += '<tr><td>operator filtered records:&nbsp;</td><td class="log-msg">'+this.opFilteredLines+'</td></tr>';
        parseStats += '<tr><td>first:&nbsp;</td><td class="log-msg">'+this.firstOpFiltered+'</td></tr>';
        parseStats += '<tr><td>last:&nbsp;</td><td class="log-msg">'+this.lastOpFiltered+'</td></tr>';
        parseStats += '<tr><td>line-range filtered records:&nbsp;</td><td class="log-msg">'+this.parseCircular.items()+'</td></tr>';
        parseStats += '<tr><td>first:&nbsp;</td><td class="log-msg">'+this.firstSaved+'</td></tr>';
        parseStats += '<tr><td>last:&nbsp;</td><td class="log-msg">'+this.lastSaved+'</td></tr>';
        parseStats += '</table>';
        
        var html = '';
        var line, thisLine, otherLine;
        var i, j;
        var displayedLine = 0;
        html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th><th>(g)</th>';
        html += '<th class="log-msg">operator</th><th class="log-msg">phrase</th></tr>';
        this.displayCircular.initReplay();
        var max = this.displayCircular.items();
        for(i = 0; i < max; i+=1)
        {
            j = this.dLines[this.displayCircular.replay()];
            line = this.lines[j];
            if(line.thisFilteredLine !== undefined)
            {
                thisLine = line.sequenceNumber;
                otherLine = (line.otherSequenceNumber !== undefined) ? line.otherSequenceNumber : '--';
                if(displayedLine%2 === 0){html += '<tr class="even">';}
                else{html += '<tr class="odd">';}
                html += '<td>'+displayedLine+'</td>';
                html += '<td>'+thisLine+'</td><td>'+otherLine+'</td>';
                html += '<td>'+line.offset+'</td><td>'+line.length+'</td>';
                html += '<td>'+line.depth+'</td>';
                html += '<td>';
                switch(line.state)
                {
                    case APG_ACTIVE:html += '&darr;&nbsp;';break;
                    case APG_MATCH:html += '<span class="match">&uarr;M</span>';break;
                    case APG_NOMATCH:html += '<span class="nomatch-arrow">&uarr;N</span>';break;
                    case APG_EMPTY:html += '<span class="empty">&uarr;E</span>';break;
                }
                html += '</td>';
                html += '<td class="log-msg">';
                html += this.indent(line.depth)+opcodeToString(line.opType);
                if(line.opType === RNM){html += '('+this.rules[line.ruleIndex].rule+') ';}
                html += '</td>';
                html += '<td class="log-msg">';
                html += modeDisplay(this.chars, line.offset, line.length, line.state);
                html += '</td></tr>';
                displayedLine+=1;
            }
        }
        html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th><th>(g)</th>';
        html += '<th class="log-msg">operator</th><th class="log-msg">phrase</th></tr>';
        html = '<table class="log-table">' + html + '</table>';
        html += '<p>';
        html += '(a)&nbsp;-&nbsp;filtered record number (sequential on displayed records)<br />';
        html += '(b)&nbsp;-&nbsp;unfiltered record number<br />';
        html += '(c)&nbsp;-&nbsp;matching unfiltered record number ("--" if matching record not displayed)<br />';
        html += '(d)&nbsp;-&nbsp;beginning phrase character number<br />';
        html += '(e)&nbsp;-&nbsp;phrase length<br />';
        html += '(f)&nbsp;-&nbsp;relative tree depth<br />';
        html += '(g)&nbsp;-&nbsp;operator state<br />';
        html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&darr;open<br />';
        html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&uarr;final<br />';
        html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;M phrase matched<br />';
        html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;N phrase not matched<br />';
        html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;E phrase matched, empty<br />';
        html += 'operator&nbsp;-&nbsp;ALT, CAT, REP, PRD, TRG, TLS, TBS or RNM(rule name)<br />';
        html += 'phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to 48 characters of the phrase being matched<br />';
        html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&para; = End of String<br />';
        html += '</p>';
        var displayStats = '';
        displayStats += '<table class="log-table">';
        displayStats += '<caption>DISPLAY FILTER</caption>';
        displayStats += '<tr><td>max displayed records:&nbsp;</td><td class="log-msg">'+this.displayFilter['max-displayed']+'</td></tr>';
        displayStats += '<tr><td>saved records:&nbsp;</td><td class="log-msg">'+this.savedLines+'</td></tr>';
        displayStats += '<tr><td>operator filtered records:&nbsp;</td><td class="log-msg">'+this.opDisplayedLines+'</td></tr>';
        displayStats += '<tr><td>first:&nbsp;</td><td class="log-msg">'+this.firstOpDisplayed+'</td></tr>';
        displayStats += '<tr><td>last:&nbsp;</td><td class="log-msg">'+this.lastOpDisplayed+'</td></tr>';
        displayStats += '<tr><td>line-range filtered records:&nbsp;</td><td class="log-msg">'+this.displayedLines+'</td></tr>';
        displayStats += '<tr><td>first:&nbsp;</td><td class="log-msg">'+this.firstDisplayed+'</td></tr>';
        displayStats += '<tr><td>last:&nbsp;</td><td class="log-msg">'+this.lastDisplayed+'</td></tr>';
        displayStats += '</table>';
        var tableHtml = '';
        tableHtml += '<table class="log-table">';
        tableHtml += '<tr><td>'+parseStats+'</td><td>&nbsp;</td><td>'+displayStats+'</td></tr>';
        tableHtml += '</table><br />';
        return tableHtml + html;
    };
    
    /*****************************************************************************/
    // filters a record on operator type according to the display filter
    this.displayFilterOp = function(line)
    {
        var opMatch = false;
        if(line.opType === RNM && this.displayFilter.rules[line.ruleIndex]){opMatch = true;}
        else if(this.displayFilter.ops[line.opType]){opMatch = true;}
        return opMatch;
    };

    /*****************************************************************************/
    // filters a record on final state according to the display filter
    this.displayFilterState = function(line)
    {
        var display = false;
        switch(line.state)
        {
            case APG_ACTIVE:
            var otherLine = line.otherSavedLine;
            if(otherLine === undefined){display = true;}
            else if(this.lines[otherLine])
            {
                switch(this.lines[otherLine].state)
                {
                    case APG_MATCH:
                    if(this.displayFilter.match){display = true;}
                    break;
                    case APG_NOMATCH:
                    if(this.displayFilter.nomatch){display = true;}
                    break;
                    case APG_EMPTY:
                    if(this.displayFilter.empty){display = true;}
                    break;
                    case APG_ACTIVE:
                    throw ['Trace: filterStateDisplay: ACTIVE state not allowed here'];
                }
            }
            break;
            case APG_MATCH:
            if(this.displayFilter.match){display = true;}
            break;
            case APG_NOMATCH:
            if(this.displayFilter.nomatch){display = true;}
            break;
            case APG_EMPTY:
            if(this.displayFilter.empty){display = true;}
            break;
        }
        return display;
    };

    /*****************************************************************************/
    // filters a record on line range according to the display filter
    this.displayLineFilter = function(thisLine, line, filter)
    {
        var ret = false;
        var thisRecord = line.sequenceNumber;
        if((thisRecord >= filter['first-record']))
        {
            switch(filter['line-range'])
            {
                case 'firstN':
                if((thisLine < this.displayMax)){ret = true;} 
                break;
                case 'record-range':
                if((thisRecord <= filter['last-record'] && thisLine < filter['max-displayed'])){ret = true;} 
                break;
                case 'lastN':
                // allow all lines
                ret = true;
                break;
                default:
                throw ['Trace: displayLineFilter: unrecognized filter[\'line-range\']: '+filter['line-range']];
                break;
            }
        }             
        return ret;             
    };
    
    /*****************************************************************************/
    // display helper - adds indenting spaces to a line
    this.indent = function(depth)
    {
        var html = '';
        for(var i = 0; i < depth; i+=1)
        {
            if(i%2 === 0){html += '&nbsp;';}
            else{html += '&#46;';}
        }
        return html;
    };
    
    /*****************************************************************************/
    // formats the phrase display in ASCII
    this.displayAscii = function(chars, offset, len, state)
    {
        var matchLen = 48;
        if(offset < 0){offset = 0;}
        var end = offset + matchLen;
        var lastChar = '';
        if(end > chars.length)
        {
            end = chars.length;
            lastChar = '<span class="eos">&para;</span>';
        }
        var htmlAscii;
        var count = 0;
        if(state === APG_MATCH){htmlAscii = '<span class="match">';}
        else{htmlAscii = '<span class="nomatch">';}
        for(var i = offset; i < end; i+=1, count+=1)
        {
            if(chars[i] === 10){htmlAscii += '<span class="control-char">LF</span>';}
            else if(chars[i] === 13){htmlAscii +='<span class="control-char">CR</span>';}
            else if(chars[i] === 9){htmlAscii += '<span class="control-char">TAB</span>';}
            else if(chars[i] < 32 || chars[i] > 126){htmlAscii +='<span class="non-ascii">x'+chars[i].toString(16)+'</span>';}
            else{htmlAscii += String.fromCharCode(chars[i]);}
            if(state === APG_MATCH && (count+1) >= len)
            {
                htmlAscii += '</span><span class="nomatch">';
            }
        }
        htmlAscii += lastChar; 
        htmlAscii += '</span>';
        return htmlAscii;
    };
    
    /*****************************************************************************/
    // formats the phrase display in hexidecimal
    this.displayHex = function(chars, offset, len, state)
    {
        var matchLen = 16;
        if(offset < 0){offset = 0;}
        var end = offset + matchLen;
        var htmlHex;
        var htmlAscii;
        var count = 0;
        var mid = matchLen/2;
        var quarter = matchLen/4;
        if(state === APG_MATCH){htmlHex = '<span class="match">';htmlAscii = '<span class="match">';}
        else{htmlHex = '<span class="nomatch">';htmlAscii = '<span class="nomatch">';}
        for(var i = offset; i < end; i+=1, count+=1)
        {
            if(count > 0)
            {
                if(count%quarter === 0){htmlHex += '&nbsp;';}
                if(count%mid === 0){htmlHex += '&nbsp;';}
            }
            if(i >= chars.length)
            {
                htmlHex += '..';
            }
            else
            {
                var hexChar = chars[i].toString(16).toUpperCase();
                if(hexChar.length === 1){htmlHex += '0' + hexChar;}
                else{htmlHex += hexChar;}
                if(chars[i] < 32 || chars[i] > 126){htmlAscii +='.';}
                else{htmlAscii += String.fromCharCode(chars[i]);}
            }
            if(state === APG_MATCH && (count+1) >= len)
            {
                htmlHex += '</span><span class="nomatch">';
                htmlAscii += '</span><span class="nomatch">';
            }
        }
        htmlHex += '</span>';
        htmlAscii += '</span>';
        return htmlHex + '&nbsp;&nbsp;' + htmlAscii;
    };

    /*****************************************************************************/
    // initialize the trace with the rules from the APG-generated opcodes
    this.initRules = function(rules)
    {
        this.rules = rules;
        this.ruleCount = this.rules.length;
        this.reconcileRules(rules, this.parseFilter);
        this.reconcileRules(rules, this.displayFilter);
        this.initMembers();
    };

    /*****************************************************************************/
    // initialize the trace with the input string character codes
    this.initChars = function(chars)
    {
        this.chars = chars;
        this.initMembers();
    };

    /*****************************************************************************/
    // initialize the parse filters stuff
    this.initMembers = function()
    {
        this.lines.length = 0;
        this.linesMax = this.parseFilter['max-saved'];
        if(this.linesMax > this.parseFilter['line-count']){this.linesMax = this.parseFilter['line-count'];}
        this.parseCircular.initCollection(this.linesMax);
        this.parseCircularReversed = false;
        
        this.unfilteredLines = 0;
        this.opFilteredLines = 0;
        this.savedLines = 0;
        
        this.firstOpFiltered = -1;
        this.lastOpFiltered = -1;
        this.firstSaved = -1;
        this.lastSaved = -1;
        
        this.initDisplay();
    };

    /*****************************************************************************/
    // initialize the display filter stuff
    this.initDisplay = function()
    {
        this.depthStack.length = 0;
        this.depth = 0;
        this.dLines.length = 0;
        this.displayMax = this.displayFilter['max-displayed'];
        if(this.displayMax > this.displayFilter['line-count']){this.displayMax = this.displayFilter['line-count'];}
        this.displayCircular.initCollection(this.displayMax);
        
        this.opDisplayedLines = 0;
        this.displayedLines = 0;
        
        this.firstOpDisplayed = -1;
        this.lastOpDisplayed = -1;
        this.firstDisplayed = -1;
        this.lastDisplayed = -1;
    };

    /*****************************************************************************/
    // MEMBER DATA & INITIALIZATION
    /*****************************************************************************/
    this.rules = [];
    this.chars = [];
    this.depthStack = [];
    this.depth = 0;
    
    // trace statistics (valid after completed trace)
    this.lines = [];
    this.parseFilter = [];
    this.parseFilter.rules = [];
    this.parseFilter['rule-map'] = [];
    this.parseFilter['rule-names'] = [];
    this.unfilteredLines = 0;
    this.opFilteredLines = 0;
    this.savedLines = 0;
    this.linesMax = 0;
    this.parseCircular = new Circular();
    this.parseCircularReversed = false;
    
    // display statistics (valid after a completed display of the trace)
    this.displayFilter = [];
    this.displayFilter.rules = [];
    this.displayFilter['rule-map'] = [];
    this.displayFilter['rule-names'] = [];
    this.opDisplayedLines = 0;
    this.displayedLines = 0;
    this.displayMax = 0;
    this.dLines = [];
    this.displayCircular = new Circular();
    
    this.firstOpFiltered = -1;
    this.lastOpFiltered = -1;
    this.firstSaved = -1;
    this.lastSaved = -1;
    
    this.firstOpDisplayed = -1;
    this.lastOpDisplayed = -1;
    this.firstDisplayed = -1;
    this.lastDisplayed = -1;

    // initialize both filters
    this.setDefaultParseFilter();
    this.setDefaultDisplayFilter();
}

</script>
<script type="text/javascript">
/* apgStats.js */
/********************************************************************
  APG - an ABNF Parser Generator
  Copyright (C) 2009 Coast to Coast Research, Inc.
 
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see
  <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
  or write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
	  author: Lowell Thomas
	          lowell@coasttocoastresearch.com
	          http://www.coasttocoastresearch.com

*********************************************************************/
/*global
ALT, CAT, REP, PRD, TRG, TBS, TLS, RNM, APG_SEM_OK, APG_PRE, APG_POST,
OP_STATE, APG_MATCH, APG_NOMATCH, APG_EMPTY,
isArray, stateToString, opcodeToString, apgAssert, charsToString
*/
"use strict";
/*CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC*/
// collects node count and other statistics during parsing
function Stats(rules)
{
    /*****************************************************************************/
    // clears the object, makes it ready to start collecting
    this.clear = function()
    {
        this.statsALT.match = 0;
        this.statsALT.nomatch = 0;
        this.statsALT.empty = 0;
        this.statsALT.backtrack = 0;
        this.statsCAT.match = 0;
        this.statsCAT.nomatch = 0;
        this.statsCAT.empty = 0;
        this.statsREP.match = 0;
        this.statsREP.nomatch = 0;
        this.statsREP.empty = 0;
        this.statsREP.backtrack = 0;
        this.statsPRD.match = 0;
        this.statsPRD.nomatch = 0;
        this.statsPRD.empty = 0;
        this.statsPRD.backtrack = 0;
        this.statsRNM.match = 0;
        this.statsRNM.nomatch = 0;
        this.statsRNM.empty = 0;
        this.statsTRG.match = 0;
        this.statsTRG.nomatch = 0;
        this.statsTRG.empty = 0;
        this.statsTLS.match = 0;
        this.statsTLS.nomatch = 0;
        this.statsTLS.empty = 0;
        this.statsTBS.match = 0;
        this.statsTBS.nomatch = 0;
        this.statsTBS.empty = 0;
        if(this.rules)
        {
            for(var i = 0; i < this.rules.length; i+=1)
            {
                this.statsRules[i].match = 0;
                this.statsRules[i].nomatch = 0;
                this.statsRules[i].empty = 0;
                this.statsRules[i].rule = this.rules[i].rule;
            }
        }
    };

    /*****************************************************************************/
    // the primary interface with the parser
    // the parser calls this function to collect statistics after completion of each node
    // op - the opcode of the node
    // state - the final state after node completion
    this.collect = function(op, state)
    {
        var whichState = '';
        switch(state[OP_STATE])
        {
            case APG_MATCH:
            whichState = 'match';
            break;
            
            case APG_NOMATCH:
            whichState = 'nomatch';
            break;
            
            case APG_EMPTY:
            whichState = 'empty';
            break;
            
            default:
            throw ['Trace.collect: invalid state: ' + state[OP_STATE]];
            
        }
        switch(op.type)
        {
            case ALT:
            this.statsALT[whichState]+=1;
            break;
            
            case CAT:
            this.statsCAT[whichState]+=1;
            break;
            
            case REP:
            this.statsREP[whichState]+=1;
            break;
            
            case PRD:
            this.statsPRD[whichState]+=1;
            break;
            
            case RNM:
            this.statsRNM[whichState]+=1;
            if(this.statsRules){this.statsRules[op.ruleIndex][whichState]+=1;}
            break;
            
            case TRG:
            this.statsTRG[whichState]+=1;
            break;
            
            case TLS:
            this.statsTLS[whichState]+=1;
            break;
            
            case TBS:
            this.statsTBS[whichState]+=1;
            break;
            
            default:
            throw ['Trace.collect: invalid opcode type: ' + op.type];
        }
    };
    
    /*****************************************************************************/
    // records back tracking statistics after ALT, REP or PRD back tracks
    this.backtrack = function(op)
    {
        switch(op.type)
        {
            case ALT:
            this.statsALT.backtrack+=1;
            break;
            
            case REP:
            this.statsREP.backtrack+=1;
            break;
            
            case PRD:
            this.statsPRD.backtrack+=1;
            break;
            
            default:
            throw ['Trace.backtrack: invalid opcode type: ' + op.type];
        }
    };
    
    /*****************************************************************************/
    // helper function for sorting the display of stats
    function compareCount(lhs, rhs)
    {
        var totalLhs, totalRhs;
        totalLhs = lhs.match + lhs.empty + lhs.nomatch;
        totalRhs = rhs.match + rhs.empty + rhs.nomatch;
        if(totalLhs < totalRhs){return 1;}
        if(totalLhs > totalRhs){return -1;}
        return 0;
    }
    
    /*****************************************************************************/
    // helper function for sorting the display of stats
    function compareName(lhs, rhs)
    {
        var nameLhs, nameRhs, lenLhs, lenRhs, len, i;
        nameLhs = lhs.rule.toLowerCase();
        nameRhs = rhs.rule.toLowerCase();
        lenLhs = nameLhs.length;
        lenRhs = nameRhs.length;
        len = (lenLhs < lenRhs) ? lenLhs : lenRhs;
        for(i = 0; i < len; i+=1)
        {
            if(nameLhs[i] < nameRhs[i]){return -1;}
            if(nameLhs[i] > nameRhs[i]){return 1;}
        }
        if(lenLhs < lenRhs){return -1;}
        if(lenLhs > lenRhs){return 1;}
        return 0;
    }
    
    /*****************************************************************************/
    // returns HTML tablular display of the statistics
    // caption - option table caption
    this.display = function(caption)
    {
        var i, tot, total, html = '';
        total = [];
        total.match = this.statsALT.match +
            this.statsCAT.match +
            this.statsREP.match +
            this.statsPRD.match +
            this.statsRNM.match +
            this.statsTRG.match +
            this.statsTBS.match +
            this.statsTLS.match;
        total.nomatch = this.statsALT.nomatch +
            this.statsCAT.nomatch +
            this.statsREP.nomatch +
            this.statsPRD.nomatch +
            this.statsRNM.nomatch +
            this.statsTRG.nomatch +
            this.statsTBS.nomatch +
            this.statsTLS.nomatch;
        total.empty = this.statsALT.empty +
            this.statsCAT.empty +
            this.statsREP.empty +
            this.statsPRD.empty +
            this.statsRNM.empty +
            this.statsTRG.empty +
            this.statsTBS.empty +
            this.statsTLS.empty;
        total.backtrack = this.statsALT.backtrack +
            this.statsREP.backtrack +
            this.statsPRD.backtrack;
            
        if(this.statsRules)
        {
            this.statsRules.sort(compareName);
            this.statsRules.sort(compareCount);
        }

        html += '<table class="stats">';
        if(typeof(caption) === 'string')
        {
            html += '<caption>'+caption+'</caption>';
        }

        html += '<tr>';
        html += '<th>';
        html += '';
        html += '</th>';
        html += '<th>';
        html += 'MATCH';
        html += '</th>';
        html += '<th>';
        html += 'NOMATCH';
        html += '</th>';
        html += '<th>';
        html += 'EMPTY';
        html += '</th>';
        html += '<th>';
        html += 'ALL';
        html += '</th>';
        html += '<th>';
        html += 'BACKTRACKS';
        html += '</th>';
        html += '</tr>';

        html += '<tr>';
        html += '<td>';
        html += 'ALT';
        html += '</td>';
        html += '<td>';
        html += this.statsALT.match;
        html += '</td>';
        html += '<td>';
        html += this.statsALT.nomatch;
        html += '</td>';
        html += '<td>';
        html += this.statsALT.empty;
        html += '</td>';
        html += '<td>';
        html += (this.statsALT.match + this.statsALT.nomatch + this.statsALT.empty);
        html += '</td>';
        html += '<td>';
        html += this.statsALT.backtrack;
        html += '</td>';
        html += '</tr>';
        
        html += '<tr>';
        html += '<td>';
        html += 'CAT';
        html += '</td>';
        html += '<td>';
        html += this.statsCAT.match;
        html += '</td>';
        html += '<td>';
        html += this.statsCAT.nomatch;
        html += '</td>';
        html += '<td>';
        html += this.statsCAT.empty;
        html += '</td>';
        html += '<td>';
        html += (this.statsCAT.match + this.statsCAT.nomatch + this.statsCAT.empty);
        html += '</td>';
        html += '<td>';
        html += '';
        html += '</td>';
        html += '</tr>';
        
        html += '<tr>';
        html += '<td>';
        html += 'REP';
        html += '</td>';
        html += '<td>';
        html += this.statsREP.match;
        html += '</td>';
        html += '<td>';
        html += this.statsREP.nomatch;
        html += '</td>';
        html += '<td>';
        html += this.statsREP.empty;
        html += '</td>';
        html += '<td>';
        html += (this.statsREP.match + this.statsREP.nomatch + this.statsREP.empty);
        html += '</td>';
        html += '<td>';
        html += this.statsREP.backtrack;
        html += '</td>';
        html += '</tr>';
        
        html += '<tr>';
        html += '<td>';
        html += 'PRD';
        html += '</td>';
        html += '<td>';
        html += this.statsPRD.match;
        html += '</td>';
        html += '<td>';
        html += this.statsPRD.nomatch;
        html += '</td>';
        html += '<td>';
        html += this.statsPRD.empty;
        html += '</td>';
        html += '<td>';
        html += (this.statsPRD.match + this.statsPRD.nomatch + this.statsPRD.empty);
        html += '</td>';
        html += '<td>';
        html += this.statsPRD.backtrack;
        html += '</td>';
        html += '</tr>';
        
        html += '<tr>';
        html += '<td>';
        html += 'RNM';
        html += '</td>';
        html += '<td>';
        html += this.statsRNM.match;
        html += '</td>';
        html += '<td>';
        html += this.statsRNM.nomatch;
        html += '</td>';
        html += '<td>';
        html += this.statsRNM.empty;
        html += '</td>';
        html += '<td>';
        html += (this.statsRNM.match + this.statsRNM.nomatch + this.statsRNM.empty);
        html += '</td>';
        html += '<td>';
        html += '';
        html += '</td>';
        html += '</tr>';
        
        html += '<tr>';
        html += '<td>';
        html += 'TRG';
        html += '</td>';
        html += '<td>';
        html += this.statsTRG.match;
        html += '</td>';
        html += '<td>';
        html += this.statsTRG.nomatch;
        html += '</td>';
        html += '<td>';
        html += this.statsTRG.empty;
        html += '</td>';
        html += '<td>';
        html += (this.statsTRG.match + this.statsTRG.nomatch + this.statsTRG.empty);
        html += '</td>';
        html += '<td>';
        html += '';
        html += '</td>';
        html += '</tr>';
        
        html += '<tr>';
        html += '<td>';
        html += 'TBS';
        html += '</td>';
        html += '<td>';
        html += this.statsTBS.match;
        html += '</td>';
        html += '<td>';
        html += this.statsTBS.nomatch;
        html += '</td>';
        html += '<td>';
        html += this.statsTBS.empty;
        html += '</td>';
        html += '<td>';
        html += (this.statsTBS.match + this.statsTBS.nomatch + this.statsTBS.empty);
        html += '</td>';
        html += '<td>';
        html += '';
        html += '</td>';
        html += '</tr>';
        
        html += '<tr>';
        html += '<td>';
        html += 'TLS';
        html += '</td>';
        html += '<td>';
        html += this.statsTLS.match;
        html += '</td>';
        html += '<td>';
        html += this.statsTLS.nomatch;
        html += '</td>';
        html += '<td>';
        html += this.statsTLS.empty;
        html += '</td>';
        html += '<td>';
        html += (this.statsTLS.match + this.statsTLS.nomatch + this.statsTLS.empty);
        html += '</td>';
        html += '<td>';
        html += '';
        html += '</td>';
        html += '</tr>';
        
        html += '<tr>';
        html += '<td>';
        html += 'TOTAL';
        html += '</td>';
        html += '<td>';
        html += total.match;
        html += '</td>';
        html += '<td>';
        html += total.nomatch;
        html += '</td>';
        html += '<td>';
        html += total.empty;
        html += '</td>';
        html += '<td>';
        html += (total.match + total.nomatch + total.empty);
        html += '</td>';
        html += '<td>';
        html += total.backtrack;
        html += '</td>';
        html += '</tr>';

        html += '<tr>';
        html += '<td colspan="5">';
        html += '</td>';
        html += '<th class="stats-hdr"  colspan="6">';
        html += 'RULE NAME';
        html += '</th>';
        html += '</tr>';
        
        if(this.statsRules)
        {
            for(i = 0; i < this.rules.length; i+=1)
            {
                tot = this.statsRules[i].match + this.statsRules[i].nomatch + this.statsRules[i].empty;
                if(tot > 0)
                {
                    html += '<tr>';
                    html += '<td>';
                    html += '</td>';
                    html += '<td>';
                    html += this.statsRules[i].match;
                    html += '</td>';
                    html += '<td>';
                    html += this.statsRules[i].nomatch;
                    html += '</td>';
                    html += '<td>';
                    html += this.statsRules[i].empty;
                    html += '</td>';
                    html += '<td>';
                    html += tot;
                    html += '</td>';
                    html += '<td class="stats-hdr">';
                    html += this.statsRules[i].rule;
                    html += '</td>';
                    html += '</tr>';
                }
            }
        }
        
        html += '</table>';
        return html;
    };

    this.statsALT = [];
    this.statsCAT = [];
    this.statsREP = [];
    this.statsPRD = [];
    this.statsRNM = [];
    this.statsTRG = [];
    this.statsTLS = [];
    this.statsTBS = [];
    this.statsRules = null;
    this.rules = null;
    if(isArray(rules))
    {
        this.rules = rules;
        this.statsRules = [];
        for(var i = 0; i < this.rules.length; i+=1)
        {
            this.statsRules[i] = [];
        }
    }
    this.clear();
}

</script>
<script type="text/javascript">
/* apgAst.js */
/********************************************************************
  APG - an ABNF Parser Generator
  Copyright (C) 2009 Coast to Coast Research, Inc.
 
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see
  <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
  or write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
	  author: Lowell Thomas
	          lowell@coasttocoastresearch.com
	          http://www.coasttocoastresearch.com

*********************************************************************/
/*global
ALT, CAT, REP, PRD, TRG, TBS, TLS, RNM,
isArray, stateToString, opcodeToString, apgAssert
*/
"use strict";
/*CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC*/
// AST CLASS
// records a subset of the RNM nodes of a parse tree
// list - a list of true/false values for each rule name in the grammar
// rules - the list of rules from the APG-generated opcodes
// ruleIds - the list of rule IDs from the APG-generated opcodes
// chars - the array of character codes for the input string
function Ast(list, rules, ruleIds, chars)
{
    this.rules = rules;
    this.chars = chars;
    this.ruleIds = ruleIds;
    this.inPRD = 0;
    this.astList = [];
    this.ast = [];
    this.rulePhrases = [];
    this.ruleCount = rules.length;

    var i;
    for(i=0; i < this.ruleCount; i+=1)
    {
        // initialize the AST rule name node list
        if(list[i] === true){this.astList[i] = [];}
        else{this.astList[i] = null;}

        // initialize the rule phrases
        this.rulePhrases[i] = [];
    }
    
    /*****************************************************************************/
    // clears the array of nodes
    this.clear = function()
    {
        this.ast.length = 0;
    };
    
    /*****************************************************************************/
    // returns true if the rule corresponding to ruleIndex is a rule retained in the AST
    this.ruleDefined = function(ruleIndex)
    {
        return (this.astList[ruleIndex] !== null);
    };
    
    // saves a node to the AST during downward traversal of the syntax tree
    // ruleIndex - index of the rule name of the RNM  node
    this.down = function(ruleIndex)
    {
        var thisIndex = this.ast.length;
        if(this.inPRD === 0)
        {
            // only record this node if not in a PRD opcode branch
            this.ast[thisIndex] = []; 
            this.ast[thisIndex].down = true;
            this.ast[thisIndex].ruleIndex = ruleIndex; 
            this.ast[thisIndex].upIndex = null; 
        } 
        return thisIndex;
    };
    
    // saves a node to the AST during upward traversal of the syntax tree
    // downIndex - AST record index for the corresponding downward index
    // phraseIndex - offset into the character code array of the input string
    //               for the beginning of the matched phrase
    // phraseLength - number of characters in the matched phrase
    /*****************************************************************************/
    this.up = function(downIndex, phraseIndex, phraseLength)
    {
        var thisIndex = this.ast.length;
        if(this.inPRD === 0)
        {
            // only record this node if not in a PRD opcode branch
            this.ast[thisIndex] = []; 
            this.ast[thisIndex].down = false;
            this.ast[thisIndex].downIndex = downIndex;
            this.ast[thisIndex].phraseIndex = phraseIndex;
            this.ast[thisIndex].phraseLength = phraseLength;
            this.ast[downIndex].upIndex = thisIndex; 
        }
        return thisIndex;
    };

    /*****************************************************************************/
    // truncate all saved AST node records above "length" records
    // used to delete AST node records saved in a branch that ultimately failed
    // and had to be backtracked over
    this.truncate = function(length)
    {
        if(this.inPRD === 0){this.ast.length = length;}
    };
    
    /*****************************************************************************/
    // returns the number of AST records currently saved
    this.currentLength = function()
    {
        return this.ast.length;
    };
    
    /*****************************************************************************/
    // specialty function to aid EventLoop() in constructing the drop down list
    // of matched phrases for interactive display
    this.countPhrases = function()
    {
        for(var i = 0; i < this.ast.length; i+=1)
        {
            if(this.ast[i].down)
            {
                // count and index the phrase
                this.rulePhrases[this.ast[i].ruleIndex].push(this.ast[i].upIndex);
            }
        }
    };

    /*****************************************************************************/
    // specialty function to aid EventLoop() in constructing the drop down list
    // of matched phrases for interactive display
    this.getDropDownOptions = function(options)
    {
        for(var i = 0; i < this.ruleCount; i+=1)
        {
            var j = this.ruleIds[i];
            options[j] = [];
            options[j].rule = this.rules[j].rule;
            options[j]['phrase-count'] = this.rulePhrases[j].length;
        }
    };
    
    /*****************************************************************************/
    // returns HTML ASCII-formatted input string with highlighted phrases for the
    // ruleIndex rule name
    this.displayPhrasesAscii = function(ruleIndex)
    {
        var html = '';
        var list = [];
        var stack = [];
        var listIndex = 0;
        var node;
        var nextNode;

        list = this.rulePhrases[ruleIndex];
        if(list[listIndex] !== undefined)
        {
            nextNode = this.ast[list[listIndex]];
        }
        else{nextNode = undefined;}
        for(var i = 0; i < this.chars.length; i+=1)
        {
            if(nextNode && nextNode.phraseIndex === i)
            {
                if(nextNode.phraseLength === 0)
                {
                    // empty phrase
                    html += '<span class="ast-empty">&epsilon;</span>';
                    while(true)
                    {
                        listIndex+=1;
                        nextNode = (list[listIndex] !== undefined) ? this.ast[list[listIndex]] : undefined;
                        if(nextNode && nextNode.phraseIndex === i)
                        {
                            // empty phrase
                            html += '<span class="ast-empty">&epsilon;</span>';
                        }
                        else{break;}
                    }
                }
                else
                {
                    // open the next highlighted phrase
                    if(stack.length%2 === 0){html += '<span class="ast-highlight-even">';}
                    else{html += '<span class="ast-highlight-odd">';}
                    stack.push(nextNode);
                    listIndex+=1;
                    nextNode = (list[listIndex] !== undefined) ? this.ast[list[listIndex]] : undefined;
                }
            }
            
            if(this.chars[i] === 10){html += '<span class="control-char">LF</span><br />';}
            else if(this.chars[i] === 13){html +='<span class="control-char">CR</span>';}
            else if(this.chars[i] === 9){html += '<span class="control-char">TAB</span>';}
            else if(this.chars[i] < 32 || this.chars[i] > 126)
                {html +='<span class="non-ascii">x'+this.chars[i].toString(16).toUpperCase()+'</span>';}
            else if(this.chars[i] === 32){html += '&nbsp;';}
            else{html += '&#'+this.chars[i];}
            
            // check for end of last opened phrase
            if(stack.length > 0)
            {
                node = stack[stack.length - 1];
                while(node && (node.phraseIndex + node.phraseLength - 1) === i)
                {
                    html += '</span>';
                    stack.pop();
                    node = stack[stack.length - 1];
                }
            }
        }
        if(stack.length > 0)
        {
            apgAssert(stack.length === 1, 'displayPhrasesAscii: stack length: '+stack.length);
            html += '</span>';
            stack.pop();
        }
        
        return html;
    };

    /*****************************************************************************/
    // returns HTML hexidecimal-formatted input string with highlighted phrases for the
    // ruleIndex rule name
    this.displayPhrasesHex = function(ruleIndex)
    {
        var html = '';
        var htmlHex = '';
        var htmlAscii = '';
        var list = [];
        var stack = [];
        var listIndex = 0;
        var node;
        var nextNode;
        var hexChar;
        var spanEven = '<span class="ast-highlight-even">';
        var spanOdd = '<span class="ast-highlight-odd">';
        var emptyHex = '<span class="ast-empty">00</span>';
        var emptyAscii = '<span class="ast-empty">&epsilon;</span>';
        
        var count = 0;
        var matchLen = 24;

        list = this.rulePhrases[ruleIndex];
        if(list[listIndex] !== undefined)
        {
            nextNode = this.ast[list[listIndex]];
        }
        else{nextNode = undefined;}
        for(var i = 0; i < this.chars.length; i+=1)
        {
            if(nextNode && nextNode.phraseIndex === i)
            {
                if(nextNode.phraseLength === 0)
                {
                    // empty phrase
                    htmlAscii += emptyAscii;
                    htmlHex += emptyHex;
                    count+=1;
                    if(count === matchLen)
                    {
                        htmlHex += '<br />';
                        htmlAscii += '<br />';
                        count = 0;
                    }
                    else
                    {
                        if(count%4 === 0){htmlHex += '&nbsp;';}
                    }
                    while(true)
                    {
                        listIndex+=1;
                        nextNode = (list[listIndex] !== undefined) ? this.ast[list[listIndex]] : undefined;
                        if(nextNode && nextNode.phraseIndex === i)
                        {
                            // empty phrase
                            htmlAscii += emptyAscii;
                            htmlHex += emptyHex;
                            count+=1;
                            if(count === matchLen)
                            {
                                htmlHex += '<br />';
                                htmlAscii += '<br />';
                                count = 0;
                            }
                            else
                            {
                                if(count%4 === 0){htmlHex += '&nbsp;';}
                            }
                        }
                        else{break;}
                    }
                }
                else
                {
                    // open the next highlighted phrase
                    if(stack.length%2 === 0){htmlAscii += spanEven; htmlHex += spanEven;}
                    else{htmlAscii += spanOdd; htmlHex += spanOdd;}
                    stack.push(nextNode);
                    listIndex+=1;
                    nextNode = (list[listIndex] !== undefined) ? this.ast[list[listIndex]] : undefined;
                }
            }
            
            if(this.chars[i] < 32 || this.chars[i] > 126){htmlAscii += '&#46;';}
            else if(this.chars[i] === 32){htmlAscii += '&nbsp;';}
            else{htmlAscii += '&#'+this.chars[i];}
            hexChar = this.chars[i].toString(16).toUpperCase();
            if(hexChar.length === 1){htmlHex += '0' + hexChar;}
            else{htmlHex += hexChar;}
            // check for end of last opened phrase
            if(stack.length > 0)
            {
                node = stack[stack.length - 1];
                if((node.phraseIndex + node.phraseLength - 1) === i)
                {
                    htmlHex += '</span>';
                    htmlAscii += '</span>';
                    stack.pop();
                }
            }
            
            count+=1;
            if(count === matchLen)
            {
                htmlHex += '<br />';
                htmlAscii += '<br />';
                count = 0;
            }
            else
            {
                if(count%4 === 0){htmlHex += '&nbsp;';}
            }
            
        }
        if(stack.length > 0)
        {
            apgAssert(stack.length === 1, 'displayPhrasesHex: stack length: '+stack.length);
            html += '</span>';
            stack.pop();
        }
        html += '<pre><table class="phrase-table"><tr><td>'+htmlHex+'</td><td>'+htmlAscii+'</td></tr></table></pre>';
        return html;
    };
    
    /*****************************************************************************/
    // helper function for dump() of the AST
    function printLine(indent, up, name, phraseIndex, phraseLength, chars)
    {
        var out = "";
        var i = 0;
        for(; i < indent; i+=1)
        {
            out += '&nbsp;';
        }
        if(up){out += '&uarr;';}
        else{out += '&darr;';}
        out += name+': ['+phraseIndex+']['+phraseLength+']';
        out += '<br />';
        return out;
    }

    /*****************************************************************************/
    // mostly for debugging
    // gives a quick HTML formatted dump of the entire AST
    this.dump = function(rules, chars)
    {
        var i, indent, downIndex, upIndex, ruleIndex, name, index, count;
        var html = '';

        html += 'AST dump:';
        html += '<br />';
        indent = 0;
        i = 0;
        for(; i < this.ast.length; i+=1)
        {
            if(this.ast[i].down)
            {
                downIndex = i;
                upIndex = this.ast[downIndex].upIndex;
                ruleIndex = this.ast[downIndex].ruleIndex;
                name = rules[ruleIndex].rule;
                index = this.ast[upIndex].phraseIndex;
                count = this.ast[upIndex].phraseLength;
                html += printLine(indent, false, name, index, count, chars);
                indent+=1;
            }
            else
            {
                indent-=1;
                upIndex = i;
                downIndex = this.ast[upIndex].downIndex;
                ruleIndex = this.ast[downIndex].ruleIndex;
                name = rules[ruleIndex].rule;
                index = this.ast[upIndex].phraseIndex;
                count = this.ast[upIndex].phraseLength;
                html += printLine(indent, true, name, index, count, chars);
            }
        }
        return html;
    };
}

</script>
<!-- include generated parser -->
<script type="text/javascript">
/* ABNFOpcodes.js */
/********************************************************************
APG - an ABNF Parser Generator
Copyright (C) 2009 Coast to Coast Research, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see
<http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
or write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

author: Lowell Thomas
lowell@coasttocoastresearch.com
http://www.coasttocoastresearch.com

*********************************************************************/
function ABNFOpcodes()
{
    // SUMMARY
    // string table length: 117
    //               rules: 28
    //             opcodes: 221

    // string table
    this.stringTable = [];
    this.stringTable[0] = 47;
    this.stringTable[1] = 47;
    this.stringTable[2] = 94;
    this.stringTable[3] = 36;
    this.stringTable[4] = 103;
    this.stringTable[5] = 105;
    this.stringTable[6] = 109;
    this.stringTable[7] = 124;
    this.stringTable[8] = 40;
    this.stringTable[9] = 41;
    this.stringTable[10] = 63;
    this.stringTable[11] = 58;
    this.stringTable[12] = 61;
    this.stringTable[13] = 33;
    this.stringTable[14] = 91;
    this.stringTable[15] = 93;
    this.stringTable[16] = 94;
    this.stringTable[17] = 45;
    this.stringTable[18] = 63;
    this.stringTable[19] = 42;
    this.stringTable[20] = 43;
    this.stringTable[21] = 63;
    this.stringTable[22] = 123;
    this.stringTable[23] = 44;
    this.stringTable[24] = 125;
    this.stringTable[25] = 92;
    this.stringTable[26] = 98;
    this.stringTable[27] = 102;
    this.stringTable[28] = 110;
    this.stringTable[29] = 114;
    this.stringTable[30] = 116;
    this.stringTable[31] = 117;
    this.stringTable[32] = 68;
    this.stringTable[33] = 83;
    this.stringTable[34] = 87;
    this.stringTable[35] = 100;
    this.stringTable[36] = 115;
    this.stringTable[37] = 119;
    this.stringTable[38] = 92;
    this.stringTable[39] = 102;
    this.stringTable[40] = 110;
    this.stringTable[41] = 114;
    this.stringTable[42] = 116;
    this.stringTable[43] = 117;
    this.stringTable[44] = 66;
    this.stringTable[45] = 68;
    this.stringTable[46] = 83;
    this.stringTable[47] = 87;
    this.stringTable[48] = 98;
    this.stringTable[49] = 100;
    this.stringTable[50] = 115;
    this.stringTable[51] = 119;
    this.stringTable[52] = 35;
    this.stringTable[53] = 37;
    this.stringTable[54] = 38;
    this.stringTable[55] = 33;
    this.stringTable[56] = 39;
    this.stringTable[57] = 44;
    this.stringTable[58] = 45;
    this.stringTable[59] = 58;
    this.stringTable[60] = 59;
    this.stringTable[61] = 60;
    this.stringTable[62] = 61;
    this.stringTable[63] = 62;
    this.stringTable[64] = 64;
    this.stringTable[65] = 95;
    this.stringTable[66] = 96;
    this.stringTable[67] = 126;
    this.stringTable[68] = 46;
    this.stringTable[69] = 123;
    this.stringTable[70] = 125;
    this.stringTable[71] = 40;
    this.stringTable[72] = 41;
    this.stringTable[73] = 46;
    this.stringTable[74] = 36;
    this.stringTable[75] = 43;
    this.stringTable[76] = 42;
    this.stringTable[77] = 63;
    this.stringTable[78] = 124;
    this.stringTable[79] = 35;
    this.stringTable[80] = 37;
    this.stringTable[81] = 38;
    this.stringTable[82] = 33;
    this.stringTable[83] = 39;
    this.stringTable[84] = 44;
    this.stringTable[85] = 58;
    this.stringTable[86] = 59;
    this.stringTable[87] = 60;
    this.stringTable[88] = 61;
    this.stringTable[89] = 62;
    this.stringTable[90] = 64;
    this.stringTable[91] = 95;
    this.stringTable[92] = 96;
    this.stringTable[93] = 126;
    this.stringTable[94] = 91;
    this.stringTable[95] = 92;
    this.stringTable[96] = 93;
    this.stringTable[97] = 94;
    this.stringTable[98] = 47;
    this.stringTable[99] = 123;
    this.stringTable[100] = 125;
    this.stringTable[101] = 40;
    this.stringTable[102] = 41;
    this.stringTable[103] = 63;
    this.stringTable[104] = 43;
    this.stringTable[105] = 42;
    this.stringTable[106] = 124;
    this.stringTable[107] = 46;
    this.stringTable[108] = 94;
    this.stringTable[109] = 36;
    this.stringTable[110] = 32;
    this.stringTable[111] = 45;
    this.stringTable[112] = 91;
    this.stringTable[113] = 92;
    this.stringTable[114] = 93;
    this.stringTable[115] = 94;
    this.stringTable[116] = 32;

    // rule identifiers
    this.ruleIds = [];
    this.ruleIds.regexpliteral = 0;
    this.ruleIds.regexpatstart = 1;
    this.ruleIds.regexpatend = 2;
    this.ruleIds.regexpoptions = 3;
    this.ruleIds.regexpalternative = 4;
    this.ruleIds.regexpsequence = 5;
    this.ruleIds.regexpfactorword = 6;
    this.ruleIds.regexpgroup = 7;
    this.ruleIds.regexpgroupcapture = 8;
    this.ruleIds.regexpclass = 9;
    this.ruleIds.regexpclassnegative = 10;
    this.ruleIds.regexpcharrange = 11;
    this.ruleIds.regexpcharstart = 12;
    this.ruleIds.regexpcharend = 13;
    this.ruleIds.regexpclassword = 14;
    this.ruleIds.regexpquantifier = 15;
    this.ruleIds.regexpquantifierrange = 16;
    this.ruleIds.regexpclassescape = 17;
    this.ruleIds.regexpescape = 18;
    this.ruleIds.charfactor = 19;
    this.ruleIds.charclass = 20;
    this.ruleIds.charspecialfactor = 21;
    this.ruleIds.charspecial = 22;
    this.ruleIds.min = 23;
    this.ruleIds.max = 24;
    this.ruleIds.hexdig = 25;
    this.ruleIds.digit = 26;
    this.ruleIds.alpha = 27;

    // rule identifiers (alphabetical)
    this.ruleIds[0] = 27; // ALPHA
    this.ruleIds[1] = 20; // charclass
    this.ruleIds[2] = 19; // charfactor
    this.ruleIds[3] = 22; // charspecial
    this.ruleIds[4] = 21; // charspecialfactor
    this.ruleIds[5] = 26; // DIGIT
    this.ruleIds[6] = 25; // HEXDIG
    this.ruleIds[7] = 24; // max
    this.ruleIds[8] = 23; // min
    this.ruleIds[9] = 4; // regexpalternative
    this.ruleIds[10] = 2; // regexpatend
    this.ruleIds[11] = 1; // regexpatstart
    this.ruleIds[12] = 13; // regexpcharend
    this.ruleIds[13] = 11; // regexpcharrange
    this.ruleIds[14] = 12; // regexpcharstart
    this.ruleIds[15] = 9; // regexpclass
    this.ruleIds[16] = 17; // regexpclassescape
    this.ruleIds[17] = 10; // regexpclassnegative
    this.ruleIds[18] = 14; // regexpclassword
    this.ruleIds[19] = 18; // regexpescape
    this.ruleIds[20] = 6; // regexpfactorword
    this.ruleIds[21] = 7; // regexpgroup
    this.ruleIds[22] = 8; // regexpgroupcapture
    this.ruleIds[23] = 0; // regexpliteral
    this.ruleIds[24] = 3; // regexpoptions
    this.ruleIds[25] = 15; // regexpquantifier
    this.ruleIds[26] = 16; // regexpquantifierrange
    this.ruleIds[27] = 5; // regexpsequence

    // rules
    this.rules = [];
    this.rules[0] = [];
    this.rules[0].rule = 'regexpliteral';
    this.rules[0].lower = 'regexpliteral';
    this.rules[0].syntax = null;
    this.rules[0].semantic = null;
    this.rules[0].opcodeIndex = 0;

    this.rules[1] = [];
    this.rules[1].rule = 'regexpatstart';
    this.rules[1].lower = 'regexpatstart';
    this.rules[1].syntax = null;
    this.rules[1].semantic = null;
    this.rules[1].opcodeIndex = 13;

    this.rules[2] = [];
    this.rules[2].rule = 'regexpatend';
    this.rules[2].lower = 'regexpatend';
    this.rules[2].syntax = null;
    this.rules[2].semantic = null;
    this.rules[2].opcodeIndex = 14;

    this.rules[3] = [];
    this.rules[3].rule = 'regexpoptions';
    this.rules[3].lower = 'regexpoptions';
    this.rules[3].syntax = null;
    this.rules[3].semantic = null;
    this.rules[3].opcodeIndex = 15;

    this.rules[4] = [];
    this.rules[4].rule = 'regexpalternative';
    this.rules[4].lower = 'regexpalternative';
    this.rules[4].syntax = null;
    this.rules[4].semantic = null;
    this.rules[4].opcodeIndex = 20;

    this.rules[5] = [];
    this.rules[5].rule = 'regexpsequence';
    this.rules[5].lower = 'regexpsequence';
    this.rules[5].syntax = null;
    this.rules[5].semantic = null;
    this.rules[5].opcodeIndex = 21;

    this.rules[6] = [];
    this.rules[6].rule = 'regexpfactorword';
    this.rules[6].lower = 'regexpfactorword';
    this.rules[6].syntax = null;
    this.rules[6].semantic = null;
    this.rules[6].opcodeIndex = 29;

    this.rules[7] = [];
    this.rules[7].rule = 'regexpgroup';
    this.rules[7].lower = 'regexpgroup';
    this.rules[7].syntax = null;
    this.rules[7].semantic = null;
    this.rules[7].opcodeIndex = 33;

    this.rules[8] = [];
    this.rules[8].rule = 'regexpgroupcapture';
    this.rules[8].lower = 'regexpgroupcapture';
    this.rules[8].syntax = null;
    this.rules[8].semantic = null;
    this.rules[8].opcodeIndex = 43;

    this.rules[9] = [];
    this.rules[9].rule = 'regexpclass';
    this.rules[9].lower = 'regexpclass';
    this.rules[9].syntax = null;
    this.rules[9].semantic = null;
    this.rules[9].opcodeIndex = 50;

    this.rules[10] = [];
    this.rules[10].rule = 'regexpclassnegative';
    this.rules[10].lower = 'regexpclassnegative';
    this.rules[10].syntax = null;
    this.rules[10].semantic = null;
    this.rules[10].opcodeIndex = 59;

    this.rules[11] = [];
    this.rules[11].rule = 'regexpcharrange';
    this.rules[11].lower = 'regexpcharrange';
    this.rules[11].syntax = null;
    this.rules[11].semantic = null;
    this.rules[11].opcodeIndex = 60;

    this.rules[12] = [];
    this.rules[12].rule = 'regexpcharstart';
    this.rules[12].lower = 'regexpcharstart';
    this.rules[12].syntax = null;
    this.rules[12].semantic = null;
    this.rules[12].opcodeIndex = 64;

    this.rules[13] = [];
    this.rules[13].rule = 'regexpcharend';
    this.rules[13].lower = 'regexpcharend';
    this.rules[13].syntax = null;
    this.rules[13].semantic = null;
    this.rules[13].opcodeIndex = 67;

    this.rules[14] = [];
    this.rules[14].rule = 'regexpclassword';
    this.rules[14].lower = 'regexpclassword';
    this.rules[14].syntax = null;
    this.rules[14].semantic = null;
    this.rules[14].opcodeIndex = 70;

    this.rules[15] = [];
    this.rules[15].rule = 'regexpquantifier';
    this.rules[15].lower = 'regexpquantifier';
    this.rules[15].syntax = null;
    this.rules[15].semantic = null;
    this.rules[15].opcodeIndex = 74;

    this.rules[16] = [];
    this.rules[16].rule = 'regexpquantifierrange';
    this.rules[16].lower = 'regexpquantifierrange';
    this.rules[16].syntax = null;
    this.rules[16].semantic = null;
    this.rules[16].opcodeIndex = 82;

    this.rules[17] = [];
    this.rules[17].rule = 'regexpclassescape';
    this.rules[17].lower = 'regexpclassescape';
    this.rules[17].syntax = null;
    this.rules[17].semantic = null;
    this.rules[17].opcodeIndex = 91;

    this.rules[18] = [];
    this.rules[18].rule = 'regexpescape';
    this.rules[18].lower = 'regexpescape';
    this.rules[18].syntax = null;
    this.rules[18].semantic = null;
    this.rules[18].opcodeIndex = 113;

    this.rules[19] = [];
    this.rules[19].rule = 'charfactor';
    this.rules[19].lower = 'charfactor';
    this.rules[19].syntax = null;
    this.rules[19].semantic = null;
    this.rules[19].opcodeIndex = 136;

    this.rules[20] = [];
    this.rules[20].rule = 'charclass';
    this.rules[20].lower = 'charclass';
    this.rules[20].syntax = null;
    this.rules[20].semantic = null;
    this.rules[20].opcodeIndex = 156;

    this.rules[21] = [];
    this.rules[21].rule = 'charspecialfactor';
    this.rules[21].lower = 'charspecialfactor';
    this.rules[21].syntax = null;
    this.rules[21].semantic = null;
    this.rules[21].opcodeIndex = 184;

    this.rules[22] = [];
    this.rules[22].rule = 'charspecial';
    this.rules[22].lower = 'charspecial';
    this.rules[22].syntax = null;
    this.rules[22].semantic = null;
    this.rules[22].opcodeIndex = 202;

    this.rules[23] = [];
    this.rules[23].rule = 'min';
    this.rules[23].lower = 'min';
    this.rules[23].syntax = null;
    this.rules[23].semantic = null;
    this.rules[23].opcodeIndex = 209;

    this.rules[24] = [];
    this.rules[24].rule = 'max';
    this.rules[24].lower = 'max';
    this.rules[24].syntax = null;
    this.rules[24].semantic = null;
    this.rules[24].opcodeIndex = 211;

    this.rules[25] = [];
    this.rules[25].rule = 'HEXDIG';
    this.rules[25].lower = 'hexdig';
    this.rules[25].syntax = null;
    this.rules[25].semantic = null;
    this.rules[25].opcodeIndex = 213;

    this.rules[26] = [];
    this.rules[26].rule = 'DIGIT';
    this.rules[26].lower = 'digit';
    this.rules[26].syntax = null;
    this.rules[26].semantic = null;
    this.rules[26].opcodeIndex = 217;

    this.rules[27] = [];
    this.rules[27].rule = 'ALPHA';
    this.rules[27].lower = 'alpha';
    this.rules[27].syntax = null;
    this.rules[27].semantic = null;
    this.rules[27].opcodeIndex = 218;

    // opcodes
    this.opcodes = [];
    this.opcodes[0] = [];
    this.opcodes[0].opNext = 13;
    this.opcodes[0].type = CAT;

    this.opcodes[1] = [];
    this.opcodes[1].opNext = 2;
    this.opcodes[1].type = TLS;
    this.opcodes[1].length = 1;
    this.opcodes[1].stringIndex = 0;

    this.opcodes[2] = [];
    this.opcodes[2].opNext = 4;
    this.opcodes[2].type = REP;
    this.opcodes[2].min = 0;
    this.opcodes[2].max = 1;

    this.opcodes[3] = [];
    this.opcodes[3].opNext = 4;
    this.opcodes[3].type = RNM;
    this.opcodes[3].ruleIndex = 1;

    this.opcodes[4] = [];
    this.opcodes[4].opNext = 5;
    this.opcodes[4].type = RNM;
    this.opcodes[4].ruleIndex = 5;

    this.opcodes[5] = [];
    this.opcodes[5].opNext = 9;
    this.opcodes[5].type = REP;
    this.opcodes[5].min = 0;
    this.opcodes[5].max = Infinity;

    this.opcodes[6] = [];
    this.opcodes[6].opNext = 9;
    this.opcodes[6].type = CAT;

    this.opcodes[7] = [];
    this.opcodes[7].opNext = 8;
    this.opcodes[7].type = RNM;
    this.opcodes[7].ruleIndex = 4;

    this.opcodes[8] = [];
    this.opcodes[8].opNext = 9;
    this.opcodes[8].type = RNM;
    this.opcodes[8].ruleIndex = 5;

    this.opcodes[9] = [];
    this.opcodes[9].opNext = 11;
    this.opcodes[9].type = REP;
    this.opcodes[9].min = 0;
    this.opcodes[9].max = 1;

    this.opcodes[10] = [];
    this.opcodes[10].opNext = 11;
    this.opcodes[10].type = RNM;
    this.opcodes[10].ruleIndex = 2;

    this.opcodes[11] = [];
    this.opcodes[11].opNext = 12;
    this.opcodes[11].type = TLS;
    this.opcodes[11].length = 1;
    this.opcodes[11].stringIndex = 1;

    this.opcodes[12] = [];
    this.opcodes[12].opNext = 13;
    this.opcodes[12].type = RNM;
    this.opcodes[12].ruleIndex = 3;

    this.opcodes[13] = [];
    this.opcodes[13].opNext = 14;
    this.opcodes[13].type = TLS;
    this.opcodes[13].length = 1;
    this.opcodes[13].stringIndex = 2;

    this.opcodes[14] = [];
    this.opcodes[14].opNext = 15;
    this.opcodes[14].type = TLS;
    this.opcodes[14].length = 1;
    this.opcodes[14].stringIndex = 3;

    this.opcodes[15] = [];
    this.opcodes[15].opNext = 20;
    this.opcodes[15].type = REP;
    this.opcodes[15].min = 0;
    this.opcodes[15].max = 3;

    this.opcodes[16] = [];
    this.opcodes[16].opNext = 20;
    this.opcodes[16].type = ALT;

    this.opcodes[17] = [];
    this.opcodes[17].opNext = 18;
    this.opcodes[17].type = TLS;
    this.opcodes[17].length = 1;
    this.opcodes[17].stringIndex = 4;

    this.opcodes[18] = [];
    this.opcodes[18].opNext = 19;
    this.opcodes[18].type = TLS;
    this.opcodes[18].length = 1;
    this.opcodes[18].stringIndex = 5;

    this.opcodes[19] = [];
    this.opcodes[19].opNext = 20;
    this.opcodes[19].type = TLS;
    this.opcodes[19].length = 1;
    this.opcodes[19].stringIndex = 6;

    this.opcodes[20] = [];
    this.opcodes[20].opNext = 21;
    this.opcodes[20].type = TLS;
    this.opcodes[20].length = 1;
    this.opcodes[20].stringIndex = 7;

    this.opcodes[21] = [];
    this.opcodes[21].opNext = 29;
    this.opcodes[21].type = REP;
    this.opcodes[21].min = 1;
    this.opcodes[21].max = Infinity;

    this.opcodes[22] = [];
    this.opcodes[22].opNext = 29;
    this.opcodes[22].type = CAT;

    this.opcodes[23] = [];
    this.opcodes[23].opNext = 27;
    this.opcodes[23].type = ALT;

    this.opcodes[24] = [];
    this.opcodes[24].opNext = 25;
    this.opcodes[24].type = RNM;
    this.opcodes[24].ruleIndex = 9;

    this.opcodes[25] = [];
    this.opcodes[25].opNext = 26;
    this.opcodes[25].type = RNM;
    this.opcodes[25].ruleIndex = 7;

    this.opcodes[26] = [];
    this.opcodes[26].opNext = 27;
    this.opcodes[26].type = RNM;
    this.opcodes[26].ruleIndex = 6;

    this.opcodes[27] = [];
    this.opcodes[27].opNext = 29;
    this.opcodes[27].type = REP;
    this.opcodes[27].min = 0;
    this.opcodes[27].max = 1;

    this.opcodes[28] = [];
    this.opcodes[28].opNext = 29;
    this.opcodes[28].type = RNM;
    this.opcodes[28].ruleIndex = 15;

    this.opcodes[29] = [];
    this.opcodes[29].opNext = 33;
    this.opcodes[29].type = REP;
    this.opcodes[29].min = 1;
    this.opcodes[29].max = Infinity;

    this.opcodes[30] = [];
    this.opcodes[30].opNext = 33;
    this.opcodes[30].type = ALT;

    this.opcodes[31] = [];
    this.opcodes[31].opNext = 32;
    this.opcodes[31].type = RNM;
    this.opcodes[31].ruleIndex = 19;

    this.opcodes[32] = [];
    this.opcodes[32].opNext = 33;
    this.opcodes[32].type = RNM;
    this.opcodes[32].ruleIndex = 18;

    this.opcodes[33] = [];
    this.opcodes[33].opNext = 43;
    this.opcodes[33].type = CAT;

    this.opcodes[34] = [];
    this.opcodes[34].opNext = 35;
    this.opcodes[34].type = TLS;
    this.opcodes[34].length = 1;
    this.opcodes[34].stringIndex = 8;

    this.opcodes[35] = [];
    this.opcodes[35].opNext = 37;
    this.opcodes[35].type = REP;
    this.opcodes[35].min = 0;
    this.opcodes[35].max = 1;

    this.opcodes[36] = [];
    this.opcodes[36].opNext = 37;
    this.opcodes[36].type = RNM;
    this.opcodes[36].ruleIndex = 8;

    this.opcodes[37] = [];
    this.opcodes[37].opNext = 38;
    this.opcodes[37].type = RNM;
    this.opcodes[37].ruleIndex = 5;

    this.opcodes[38] = [];
    this.opcodes[38].opNext = 42;
    this.opcodes[38].type = REP;
    this.opcodes[38].min = 0;
    this.opcodes[38].max = Infinity;

    this.opcodes[39] = [];
    this.opcodes[39].opNext = 42;
    this.opcodes[39].type = CAT;

    this.opcodes[40] = [];
    this.opcodes[40].opNext = 41;
    this.opcodes[40].type = RNM;
    this.opcodes[40].ruleIndex = 4;

    this.opcodes[41] = [];
    this.opcodes[41].opNext = 42;
    this.opcodes[41].type = RNM;
    this.opcodes[41].ruleIndex = 5;

    this.opcodes[42] = [];
    this.opcodes[42].opNext = 43;
    this.opcodes[42].type = TLS;
    this.opcodes[42].length = 1;
    this.opcodes[42].stringIndex = 9;

    this.opcodes[43] = [];
    this.opcodes[43].opNext = 50;
    this.opcodes[43].type = CAT;

    this.opcodes[44] = [];
    this.opcodes[44].opNext = 45;
    this.opcodes[44].type = TLS;
    this.opcodes[44].length = 1;
    this.opcodes[44].stringIndex = 10;

    this.opcodes[45] = [];
    this.opcodes[45].opNext = 50;
    this.opcodes[45].type = REP;
    this.opcodes[45].min = 0;
    this.opcodes[45].max = 1;

    this.opcodes[46] = [];
    this.opcodes[46].opNext = 50;
    this.opcodes[46].type = ALT;

    this.opcodes[47] = [];
    this.opcodes[47].opNext = 48;
    this.opcodes[47].type = TLS;
    this.opcodes[47].length = 1;
    this.opcodes[47].stringIndex = 11;

    this.opcodes[48] = [];
    this.opcodes[48].opNext = 49;
    this.opcodes[48].type = TLS;
    this.opcodes[48].length = 1;
    this.opcodes[48].stringIndex = 12;

    this.opcodes[49] = [];
    this.opcodes[49].opNext = 50;
    this.opcodes[49].type = TLS;
    this.opcodes[49].length = 1;
    this.opcodes[49].stringIndex = 13;

    this.opcodes[50] = [];
    this.opcodes[50].opNext = 59;
    this.opcodes[50].type = CAT;

    this.opcodes[51] = [];
    this.opcodes[51].opNext = 52;
    this.opcodes[51].type = TLS;
    this.opcodes[51].length = 1;
    this.opcodes[51].stringIndex = 14;

    this.opcodes[52] = [];
    this.opcodes[52].opNext = 54;
    this.opcodes[52].type = REP;
    this.opcodes[52].min = 0;
    this.opcodes[52].max = 1;

    this.opcodes[53] = [];
    this.opcodes[53].opNext = 54;
    this.opcodes[53].type = RNM;
    this.opcodes[53].ruleIndex = 10;

    this.opcodes[54] = [];
    this.opcodes[54].opNext = 58;
    this.opcodes[54].type = REP;
    this.opcodes[54].min = 1;
    this.opcodes[54].max = Infinity;

    this.opcodes[55] = [];
    this.opcodes[55].opNext = 58;
    this.opcodes[55].type = ALT;

    this.opcodes[56] = [];
    this.opcodes[56].opNext = 57;
    this.opcodes[56].type = RNM;
    this.opcodes[56].ruleIndex = 11;

    this.opcodes[57] = [];
    this.opcodes[57].opNext = 58;
    this.opcodes[57].type = RNM;
    this.opcodes[57].ruleIndex = 14;

    this.opcodes[58] = [];
    this.opcodes[58].opNext = 59;
    this.opcodes[58].type = TLS;
    this.opcodes[58].length = 1;
    this.opcodes[58].stringIndex = 15;

    this.opcodes[59] = [];
    this.opcodes[59].opNext = 60;
    this.opcodes[59].type = TLS;
    this.opcodes[59].length = 1;
    this.opcodes[59].stringIndex = 16;

    this.opcodes[60] = [];
    this.opcodes[60].opNext = 64;
    this.opcodes[60].type = CAT;

    this.opcodes[61] = [];
    this.opcodes[61].opNext = 62;
    this.opcodes[61].type = RNM;
    this.opcodes[61].ruleIndex = 12;

    this.opcodes[62] = [];
    this.opcodes[62].opNext = 63;
    this.opcodes[62].type = TLS;
    this.opcodes[62].length = 1;
    this.opcodes[62].stringIndex = 17;

    this.opcodes[63] = [];
    this.opcodes[63].opNext = 64;
    this.opcodes[63].type = RNM;
    this.opcodes[63].ruleIndex = 13;

    this.opcodes[64] = [];
    this.opcodes[64].opNext = 67;
    this.opcodes[64].type = ALT;

    this.opcodes[65] = [];
    this.opcodes[65].opNext = 66;
    this.opcodes[65].type = RNM;
    this.opcodes[65].ruleIndex = 20;

    this.opcodes[66] = [];
    this.opcodes[66].opNext = 67;
    this.opcodes[66].type = RNM;
    this.opcodes[66].ruleIndex = 17;

    this.opcodes[67] = [];
    this.opcodes[67].opNext = 70;
    this.opcodes[67].type = ALT;

    this.opcodes[68] = [];
    this.opcodes[68].opNext = 69;
    this.opcodes[68].type = RNM;
    this.opcodes[68].ruleIndex = 20;

    this.opcodes[69] = [];
    this.opcodes[69].opNext = 70;
    this.opcodes[69].type = RNM;
    this.opcodes[69].ruleIndex = 17;

    this.opcodes[70] = [];
    this.opcodes[70].opNext = 74;
    this.opcodes[70].type = REP;
    this.opcodes[70].min = 1;
    this.opcodes[70].max = Infinity;

    this.opcodes[71] = [];
    this.opcodes[71].opNext = 74;
    this.opcodes[71].type = ALT;

    this.opcodes[72] = [];
    this.opcodes[72].opNext = 73;
    this.opcodes[72].type = RNM;
    this.opcodes[72].ruleIndex = 20;

    this.opcodes[73] = [];
    this.opcodes[73].opNext = 74;
    this.opcodes[73].type = RNM;
    this.opcodes[73].ruleIndex = 17;

    this.opcodes[74] = [];
    this.opcodes[74].opNext = 82;
    this.opcodes[74].type = CAT;

    this.opcodes[75] = [];
    this.opcodes[75].opNext = 80;
    this.opcodes[75].type = ALT;

    this.opcodes[76] = [];
    this.opcodes[76].opNext = 77;
    this.opcodes[76].type = TLS;
    this.opcodes[76].length = 1;
    this.opcodes[76].stringIndex = 18;

    this.opcodes[77] = [];
    this.opcodes[77].opNext = 78;
    this.opcodes[77].type = TLS;
    this.opcodes[77].length = 1;
    this.opcodes[77].stringIndex = 19;

    this.opcodes[78] = [];
    this.opcodes[78].opNext = 79;
    this.opcodes[78].type = TLS;
    this.opcodes[78].length = 1;
    this.opcodes[78].stringIndex = 20;

    this.opcodes[79] = [];
    this.opcodes[79].opNext = 80;
    this.opcodes[79].type = RNM;
    this.opcodes[79].ruleIndex = 16;

    this.opcodes[80] = [];
    this.opcodes[80].opNext = 82;
    this.opcodes[80].type = REP;
    this.opcodes[80].min = 0;
    this.opcodes[80].max = 1;

    this.opcodes[81] = [];
    this.opcodes[81].opNext = 82;
    this.opcodes[81].type = TLS;
    this.opcodes[81].length = 1;
    this.opcodes[81].stringIndex = 21;

    this.opcodes[82] = [];
    this.opcodes[82].opNext = 91;
    this.opcodes[82].type = CAT;

    this.opcodes[83] = [];
    this.opcodes[83].opNext = 84;
    this.opcodes[83].type = TLS;
    this.opcodes[83].length = 1;
    this.opcodes[83].stringIndex = 22;

    this.opcodes[84] = [];
    this.opcodes[84].opNext = 85;
    this.opcodes[84].type = RNM;
    this.opcodes[84].ruleIndex = 23;

    this.opcodes[85] = [];
    this.opcodes[85].opNext = 90;
    this.opcodes[85].type = REP;
    this.opcodes[85].min = 0;
    this.opcodes[85].max = 1;

    this.opcodes[86] = [];
    this.opcodes[86].opNext = 90;
    this.opcodes[86].type = CAT;

    this.opcodes[87] = [];
    this.opcodes[87].opNext = 88;
    this.opcodes[87].type = TLS;
    this.opcodes[87].length = 1;
    this.opcodes[87].stringIndex = 23;

    this.opcodes[88] = [];
    this.opcodes[88].opNext = 90;
    this.opcodes[88].type = REP;
    this.opcodes[88].min = 0;
    this.opcodes[88].max = 1;

    this.opcodes[89] = [];
    this.opcodes[89].opNext = 90;
    this.opcodes[89].type = RNM;
    this.opcodes[89].ruleIndex = 24;

    this.opcodes[90] = [];
    this.opcodes[90].opNext = 91;
    this.opcodes[90].type = TLS;
    this.opcodes[90].length = 1;
    this.opcodes[90].stringIndex = 24;

    this.opcodes[91] = [];
    this.opcodes[91].opNext = 113;
    this.opcodes[91].type = CAT;

    this.opcodes[92] = [];
    this.opcodes[92].opNext = 93;
    this.opcodes[92].type = TLS;
    this.opcodes[92].length = 1;
    this.opcodes[92].stringIndex = 25;

    this.opcodes[93] = [];
    this.opcodes[93].opNext = 113;
    this.opcodes[93].type = ALT;

    this.opcodes[94] = [];
    this.opcodes[94].opNext = 95;
    this.opcodes[94].type = TLS;
    this.opcodes[94].length = 1;
    this.opcodes[94].stringIndex = 26;

    this.opcodes[95] = [];
    this.opcodes[95].opNext = 96;
    this.opcodes[95].type = TLS;
    this.opcodes[95].length = 1;
    this.opcodes[95].stringIndex = 27;

    this.opcodes[96] = [];
    this.opcodes[96].opNext = 97;
    this.opcodes[96].type = TLS;
    this.opcodes[96].length = 1;
    this.opcodes[96].stringIndex = 28;

    this.opcodes[97] = [];
    this.opcodes[97].opNext = 98;
    this.opcodes[97].type = TLS;
    this.opcodes[97].length = 1;
    this.opcodes[97].stringIndex = 29;

    this.opcodes[98] = [];
    this.opcodes[98].opNext = 99;
    this.opcodes[98].type = TLS;
    this.opcodes[98].length = 1;
    this.opcodes[98].stringIndex = 30;

    this.opcodes[99] = [];
    this.opcodes[99].opNext = 105;
    this.opcodes[99].type = CAT;

    this.opcodes[100] = [];
    this.opcodes[100].opNext = 101;
    this.opcodes[100].type = TLS;
    this.opcodes[100].length = 1;
    this.opcodes[100].stringIndex = 31;

    this.opcodes[101] = [];
    this.opcodes[101].opNext = 102;
    this.opcodes[101].type = RNM;
    this.opcodes[101].ruleIndex = 25;

    this.opcodes[102] = [];
    this.opcodes[102].opNext = 103;
    this.opcodes[102].type = RNM;
    this.opcodes[102].ruleIndex = 25;

    this.opcodes[103] = [];
    this.opcodes[103].opNext = 104;
    this.opcodes[103].type = RNM;
    this.opcodes[103].ruleIndex = 25;

    this.opcodes[104] = [];
    this.opcodes[104].opNext = 105;
    this.opcodes[104].type = RNM;
    this.opcodes[104].ruleIndex = 25;

    this.opcodes[105] = [];
    this.opcodes[105].opNext = 106;
    this.opcodes[105].type = TLS;
    this.opcodes[105].length = 1;
    this.opcodes[105].stringIndex = 32;

    this.opcodes[106] = [];
    this.opcodes[106].opNext = 107;
    this.opcodes[106].type = TLS;
    this.opcodes[106].length = 1;
    this.opcodes[106].stringIndex = 33;

    this.opcodes[107] = [];
    this.opcodes[107].opNext = 108;
    this.opcodes[107].type = TLS;
    this.opcodes[107].length = 1;
    this.opcodes[107].stringIndex = 34;

    this.opcodes[108] = [];
    this.opcodes[108].opNext = 109;
    this.opcodes[108].type = TLS;
    this.opcodes[108].length = 1;
    this.opcodes[108].stringIndex = 35;

    this.opcodes[109] = [];
    this.opcodes[109].opNext = 110;
    this.opcodes[109].type = TLS;
    this.opcodes[109].length = 1;
    this.opcodes[109].stringIndex = 36;

    this.opcodes[110] = [];
    this.opcodes[110].opNext = 111;
    this.opcodes[110].type = TLS;
    this.opcodes[110].length = 1;
    this.opcodes[110].stringIndex = 37;

    this.opcodes[111] = [];
    this.opcodes[111].opNext = 112;
    this.opcodes[111].type = RNM;
    this.opcodes[111].ruleIndex = 22;

    this.opcodes[112] = [];
    this.opcodes[112].opNext = 113;
    this.opcodes[112].type = RNM;
    this.opcodes[112].ruleIndex = 26;

    this.opcodes[113] = [];
    this.opcodes[113].opNext = 136;
    this.opcodes[113].type = CAT;

    this.opcodes[114] = [];
    this.opcodes[114].opNext = 115;
    this.opcodes[114].type = TLS;
    this.opcodes[114].length = 1;
    this.opcodes[114].stringIndex = 38;

    this.opcodes[115] = [];
    this.opcodes[115].opNext = 136;
    this.opcodes[115].type = ALT;

    this.opcodes[116] = [];
    this.opcodes[116].opNext = 117;
    this.opcodes[116].type = TLS;
    this.opcodes[116].length = 1;
    this.opcodes[116].stringIndex = 39;

    this.opcodes[117] = [];
    this.opcodes[117].opNext = 118;
    this.opcodes[117].type = TLS;
    this.opcodes[117].length = 1;
    this.opcodes[117].stringIndex = 40;

    this.opcodes[118] = [];
    this.opcodes[118].opNext = 119;
    this.opcodes[118].type = TLS;
    this.opcodes[118].length = 1;
    this.opcodes[118].stringIndex = 41;

    this.opcodes[119] = [];
    this.opcodes[119].opNext = 120;
    this.opcodes[119].type = TLS;
    this.opcodes[119].length = 1;
    this.opcodes[119].stringIndex = 42;

    this.opcodes[120] = [];
    this.opcodes[120].opNext = 126;
    this.opcodes[120].type = CAT;

    this.opcodes[121] = [];
    this.opcodes[121].opNext = 122;
    this.opcodes[121].type = TLS;
    this.opcodes[121].length = 1;
    this.opcodes[121].stringIndex = 43;

    this.opcodes[122] = [];
    this.opcodes[122].opNext = 123;
    this.opcodes[122].type = RNM;
    this.opcodes[122].ruleIndex = 25;

    this.opcodes[123] = [];
    this.opcodes[123].opNext = 124;
    this.opcodes[123].type = RNM;
    this.opcodes[123].ruleIndex = 25;

    this.opcodes[124] = [];
    this.opcodes[124].opNext = 125;
    this.opcodes[124].type = RNM;
    this.opcodes[124].ruleIndex = 25;

    this.opcodes[125] = [];
    this.opcodes[125].opNext = 126;
    this.opcodes[125].type = RNM;
    this.opcodes[125].ruleIndex = 25;

    this.opcodes[126] = [];
    this.opcodes[126].opNext = 127;
    this.opcodes[126].type = TLS;
    this.opcodes[126].length = 1;
    this.opcodes[126].stringIndex = 44;

    this.opcodes[127] = [];
    this.opcodes[127].opNext = 128;
    this.opcodes[127].type = TLS;
    this.opcodes[127].length = 1;
    this.opcodes[127].stringIndex = 45;

    this.opcodes[128] = [];
    this.opcodes[128].opNext = 129;
    this.opcodes[128].type = TLS;
    this.opcodes[128].length = 1;
    this.opcodes[128].stringIndex = 46;

    this.opcodes[129] = [];
    this.opcodes[129].opNext = 130;
    this.opcodes[129].type = TLS;
    this.opcodes[129].length = 1;
    this.opcodes[129].stringIndex = 47;

    this.opcodes[130] = [];
    this.opcodes[130].opNext = 131;
    this.opcodes[130].type = TLS;
    this.opcodes[130].length = 1;
    this.opcodes[130].stringIndex = 48;

    this.opcodes[131] = [];
    this.opcodes[131].opNext = 132;
    this.opcodes[131].type = TLS;
    this.opcodes[131].length = 1;
    this.opcodes[131].stringIndex = 49;

    this.opcodes[132] = [];
    this.opcodes[132].opNext = 133;
    this.opcodes[132].type = TLS;
    this.opcodes[132].length = 1;
    this.opcodes[132].stringIndex = 50;

    this.opcodes[133] = [];
    this.opcodes[133].opNext = 134;
    this.opcodes[133].type = TLS;
    this.opcodes[133].length = 1;
    this.opcodes[133].stringIndex = 51;

    this.opcodes[134] = [];
    this.opcodes[134].opNext = 135;
    this.opcodes[134].type = RNM;
    this.opcodes[134].ruleIndex = 21;

    this.opcodes[135] = [];
    this.opcodes[135].opNext = 136;
    this.opcodes[135].type = RNM;
    this.opcodes[135].ruleIndex = 26;

    this.opcodes[136] = [];
    this.opcodes[136].opNext = 156;
    this.opcodes[136].type = ALT;

    this.opcodes[137] = [];
    this.opcodes[137].opNext = 138;
    this.opcodes[137].type = RNM;
    this.opcodes[137].ruleIndex = 27;

    this.opcodes[138] = [];
    this.opcodes[138].opNext = 139;
    this.opcodes[138].type = RNM;
    this.opcodes[138].ruleIndex = 26;

    this.opcodes[139] = [];
    this.opcodes[139].opNext = 140;
    this.opcodes[139].type = TLS;
    this.opcodes[139].length = 1;
    this.opcodes[139].stringIndex = 52;

    this.opcodes[140] = [];
    this.opcodes[140].opNext = 141;
    this.opcodes[140].type = TLS;
    this.opcodes[140].length = 1;
    this.opcodes[140].stringIndex = 53;

    this.opcodes[141] = [];
    this.opcodes[141].opNext = 142;
    this.opcodes[141].type = TLS;
    this.opcodes[141].length = 1;
    this.opcodes[141].stringIndex = 54;

    this.opcodes[142] = [];
    this.opcodes[142].opNext = 143;
    this.opcodes[142].type = TLS;
    this.opcodes[142].length = 1;
    this.opcodes[142].stringIndex = 55;

    this.opcodes[143] = [];
    this.opcodes[143].opNext = 144;
    this.opcodes[143].type = TLS;
    this.opcodes[143].length = 1;
    this.opcodes[143].stringIndex = 56;

    this.opcodes[144] = [];
    this.opcodes[144].opNext = 145;
    this.opcodes[144].type = TLS;
    this.opcodes[144].length = 1;
    this.opcodes[144].stringIndex = 57;

    this.opcodes[145] = [];
    this.opcodes[145].opNext = 146;
    this.opcodes[145].type = TLS;
    this.opcodes[145].length = 1;
    this.opcodes[145].stringIndex = 58;

    this.opcodes[146] = [];
    this.opcodes[146].opNext = 147;
    this.opcodes[146].type = TLS;
    this.opcodes[146].length = 1;
    this.opcodes[146].stringIndex = 59;

    this.opcodes[147] = [];
    this.opcodes[147].opNext = 148;
    this.opcodes[147].type = TLS;
    this.opcodes[147].length = 1;
    this.opcodes[147].stringIndex = 60;

    this.opcodes[148] = [];
    this.opcodes[148].opNext = 149;
    this.opcodes[148].type = TLS;
    this.opcodes[148].length = 1;
    this.opcodes[148].stringIndex = 61;

    this.opcodes[149] = [];
    this.opcodes[149].opNext = 150;
    this.opcodes[149].type = TLS;
    this.opcodes[149].length = 1;
    this.opcodes[149].stringIndex = 62;

    this.opcodes[150] = [];
    this.opcodes[150].opNext = 151;
    this.opcodes[150].type = TLS;
    this.opcodes[150].length = 1;
    this.opcodes[150].stringIndex = 63;

    this.opcodes[151] = [];
    this.opcodes[151].opNext = 152;
    this.opcodes[151].type = TLS;
    this.opcodes[151].length = 1;
    this.opcodes[151].stringIndex = 64;

    this.opcodes[152] = [];
    this.opcodes[152].opNext = 153;
    this.opcodes[152].type = TLS;
    this.opcodes[152].length = 1;
    this.opcodes[152].stringIndex = 65;

    this.opcodes[153] = [];
    this.opcodes[153].opNext = 154;
    this.opcodes[153].type = TLS;
    this.opcodes[153].length = 1;
    this.opcodes[153].stringIndex = 66;

    this.opcodes[154] = [];
    this.opcodes[154].opNext = 155;
    this.opcodes[154].type = TLS;
    this.opcodes[154].length = 1;
    this.opcodes[154].stringIndex = 67;

    this.opcodes[155] = [];
    this.opcodes[155].opNext = 156;
    this.opcodes[155].type = TLS;
    this.opcodes[155].length = 1;
    this.opcodes[155].stringIndex = 68;

    this.opcodes[156] = [];
    this.opcodes[156].opNext = 184;
    this.opcodes[156].type = ALT;

    this.opcodes[157] = [];
    this.opcodes[157].opNext = 158;
    this.opcodes[157].type = RNM;
    this.opcodes[157].ruleIndex = 27;

    this.opcodes[158] = [];
    this.opcodes[158].opNext = 159;
    this.opcodes[158].type = RNM;
    this.opcodes[158].ruleIndex = 26;

    this.opcodes[159] = [];
    this.opcodes[159].opNext = 160;
    this.opcodes[159].type = TLS;
    this.opcodes[159].length = 1;
    this.opcodes[159].stringIndex = 69;

    this.opcodes[160] = [];
    this.opcodes[160].opNext = 161;
    this.opcodes[160].type = TLS;
    this.opcodes[160].length = 1;
    this.opcodes[160].stringIndex = 70;

    this.opcodes[161] = [];
    this.opcodes[161].opNext = 162;
    this.opcodes[161].type = TLS;
    this.opcodes[161].length = 1;
    this.opcodes[161].stringIndex = 71;

    this.opcodes[162] = [];
    this.opcodes[162].opNext = 163;
    this.opcodes[162].type = TLS;
    this.opcodes[162].length = 1;
    this.opcodes[162].stringIndex = 72;

    this.opcodes[163] = [];
    this.opcodes[163].opNext = 164;
    this.opcodes[163].type = TLS;
    this.opcodes[163].length = 1;
    this.opcodes[163].stringIndex = 73;

    this.opcodes[164] = [];
    this.opcodes[164].opNext = 165;
    this.opcodes[164].type = TLS;
    this.opcodes[164].length = 1;
    this.opcodes[164].stringIndex = 74;

    this.opcodes[165] = [];
    this.opcodes[165].opNext = 166;
    this.opcodes[165].type = TLS;
    this.opcodes[165].length = 1;
    this.opcodes[165].stringIndex = 75;

    this.opcodes[166] = [];
    this.opcodes[166].opNext = 167;
    this.opcodes[166].type = TLS;
    this.opcodes[166].length = 1;
    this.opcodes[166].stringIndex = 76;

    this.opcodes[167] = [];
    this.opcodes[167].opNext = 168;
    this.opcodes[167].type = TLS;
    this.opcodes[167].length = 1;
    this.opcodes[167].stringIndex = 77;

    this.opcodes[168] = [];
    this.opcodes[168].opNext = 169;
    this.opcodes[168].type = TLS;
    this.opcodes[168].length = 1;
    this.opcodes[168].stringIndex = 78;

    this.opcodes[169] = [];
    this.opcodes[169].opNext = 170;
    this.opcodes[169].type = TLS;
    this.opcodes[169].length = 1;
    this.opcodes[169].stringIndex = 79;

    this.opcodes[170] = [];
    this.opcodes[170].opNext = 171;
    this.opcodes[170].type = TLS;
    this.opcodes[170].length = 1;
    this.opcodes[170].stringIndex = 80;

    this.opcodes[171] = [];
    this.opcodes[171].opNext = 172;
    this.opcodes[171].type = TLS;
    this.opcodes[171].length = 1;
    this.opcodes[171].stringIndex = 81;

    this.opcodes[172] = [];
    this.opcodes[172].opNext = 173;
    this.opcodes[172].type = TLS;
    this.opcodes[172].length = 1;
    this.opcodes[172].stringIndex = 82;

    this.opcodes[173] = [];
    this.opcodes[173].opNext = 174;
    this.opcodes[173].type = TLS;
    this.opcodes[173].length = 1;
    this.opcodes[173].stringIndex = 83;

    this.opcodes[174] = [];
    this.opcodes[174].opNext = 175;
    this.opcodes[174].type = TLS;
    this.opcodes[174].length = 1;
    this.opcodes[174].stringIndex = 84;

    this.opcodes[175] = [];
    this.opcodes[175].opNext = 176;
    this.opcodes[175].type = TLS;
    this.opcodes[175].length = 1;
    this.opcodes[175].stringIndex = 85;

    this.opcodes[176] = [];
    this.opcodes[176].opNext = 177;
    this.opcodes[176].type = TLS;
    this.opcodes[176].length = 1;
    this.opcodes[176].stringIndex = 86;

    this.opcodes[177] = [];
    this.opcodes[177].opNext = 178;
    this.opcodes[177].type = TLS;
    this.opcodes[177].length = 1;
    this.opcodes[177].stringIndex = 87;

    this.opcodes[178] = [];
    this.opcodes[178].opNext = 179;
    this.opcodes[178].type = TLS;
    this.opcodes[178].length = 1;
    this.opcodes[178].stringIndex = 88;

    this.opcodes[179] = [];
    this.opcodes[179].opNext = 180;
    this.opcodes[179].type = TLS;
    this.opcodes[179].length = 1;
    this.opcodes[179].stringIndex = 89;

    this.opcodes[180] = [];
    this.opcodes[180].opNext = 181;
    this.opcodes[180].type = TLS;
    this.opcodes[180].length = 1;
    this.opcodes[180].stringIndex = 90;

    this.opcodes[181] = [];
    this.opcodes[181].opNext = 182;
    this.opcodes[181].type = TLS;
    this.opcodes[181].length = 1;
    this.opcodes[181].stringIndex = 91;

    this.opcodes[182] = [];
    this.opcodes[182].opNext = 183;
    this.opcodes[182].type = TLS;
    this.opcodes[182].length = 1;
    this.opcodes[182].stringIndex = 92;

    this.opcodes[183] = [];
    this.opcodes[183].opNext = 184;
    this.opcodes[183].type = TLS;
    this.opcodes[183].length = 1;
    this.opcodes[183].stringIndex = 93;

    this.opcodes[184] = [];
    this.opcodes[184].opNext = 202;
    this.opcodes[184].type = ALT;

    this.opcodes[185] = [];
    this.opcodes[185].opNext = 186;
    this.opcodes[185].type = TLS;
    this.opcodes[185].length = 1;
    this.opcodes[185].stringIndex = 94;

    this.opcodes[186] = [];
    this.opcodes[186].opNext = 187;
    this.opcodes[186].type = TLS;
    this.opcodes[186].length = 1;
    this.opcodes[186].stringIndex = 95;

    this.opcodes[187] = [];
    this.opcodes[187].opNext = 188;
    this.opcodes[187].type = TLS;
    this.opcodes[187].length = 1;
    this.opcodes[187].stringIndex = 96;

    this.opcodes[188] = [];
    this.opcodes[188].opNext = 189;
    this.opcodes[188].type = TLS;
    this.opcodes[188].length = 1;
    this.opcodes[188].stringIndex = 97;

    this.opcodes[189] = [];
    this.opcodes[189].opNext = 190;
    this.opcodes[189].type = TLS;
    this.opcodes[189].length = 1;
    this.opcodes[189].stringIndex = 98;

    this.opcodes[190] = [];
    this.opcodes[190].opNext = 191;
    this.opcodes[190].type = TLS;
    this.opcodes[190].length = 1;
    this.opcodes[190].stringIndex = 99;

    this.opcodes[191] = [];
    this.opcodes[191].opNext = 192;
    this.opcodes[191].type = TLS;
    this.opcodes[191].length = 1;
    this.opcodes[191].stringIndex = 100;

    this.opcodes[192] = [];
    this.opcodes[192].opNext = 193;
    this.opcodes[192].type = TLS;
    this.opcodes[192].length = 1;
    this.opcodes[192].stringIndex = 101;

    this.opcodes[193] = [];
    this.opcodes[193].opNext = 194;
    this.opcodes[193].type = TLS;
    this.opcodes[193].length = 1;
    this.opcodes[193].stringIndex = 102;

    this.opcodes[194] = [];
    this.opcodes[194].opNext = 195;
    this.opcodes[194].type = TLS;
    this.opcodes[194].length = 1;
    this.opcodes[194].stringIndex = 103;

    this.opcodes[195] = [];
    this.opcodes[195].opNext = 196;
    this.opcodes[195].type = TLS;
    this.opcodes[195].length = 1;
    this.opcodes[195].stringIndex = 104;

    this.opcodes[196] = [];
    this.opcodes[196].opNext = 197;
    this.opcodes[196].type = TLS;
    this.opcodes[196].length = 1;
    this.opcodes[196].stringIndex = 105;

    this.opcodes[197] = [];
    this.opcodes[197].opNext = 198;
    this.opcodes[197].type = TLS;
    this.opcodes[197].length = 1;
    this.opcodes[197].stringIndex = 106;

    this.opcodes[198] = [];
    this.opcodes[198].opNext = 199;
    this.opcodes[198].type = TLS;
    this.opcodes[198].length = 1;
    this.opcodes[198].stringIndex = 107;

    this.opcodes[199] = [];
    this.opcodes[199].opNext = 200;
    this.opcodes[199].type = TLS;
    this.opcodes[199].length = 1;
    this.opcodes[199].stringIndex = 108;

    this.opcodes[200] = [];
    this.opcodes[200].opNext = 201;
    this.opcodes[200].type = TLS;
    this.opcodes[200].length = 1;
    this.opcodes[200].stringIndex = 109;

    this.opcodes[201] = [];
    this.opcodes[201].opNext = 202;
    this.opcodes[201].type = TLS;
    this.opcodes[201].length = 1;
    this.opcodes[201].stringIndex = 110;

    this.opcodes[202] = [];
    this.opcodes[202].opNext = 209;
    this.opcodes[202].type = ALT;

    this.opcodes[203] = [];
    this.opcodes[203].opNext = 204;
    this.opcodes[203].type = TLS;
    this.opcodes[203].length = 1;
    this.opcodes[203].stringIndex = 111;

    this.opcodes[204] = [];
    this.opcodes[204].opNext = 205;
    this.opcodes[204].type = TLS;
    this.opcodes[204].length = 1;
    this.opcodes[204].stringIndex = 112;

    this.opcodes[205] = [];
    this.opcodes[205].opNext = 206;
    this.opcodes[205].type = TLS;
    this.opcodes[205].length = 1;
    this.opcodes[205].stringIndex = 113;

    this.opcodes[206] = [];
    this.opcodes[206].opNext = 207;
    this.opcodes[206].type = TLS;
    this.opcodes[206].length = 1;
    this.opcodes[206].stringIndex = 114;

    this.opcodes[207] = [];
    this.opcodes[207].opNext = 208;
    this.opcodes[207].type = TLS;
    this.opcodes[207].length = 1;
    this.opcodes[207].stringIndex = 115;

    this.opcodes[208] = [];
    this.opcodes[208].opNext = 209;
    this.opcodes[208].type = TLS;
    this.opcodes[208].length = 1;
    this.opcodes[208].stringIndex = 116;

    this.opcodes[209] = [];
    this.opcodes[209].opNext = 211;
    this.opcodes[209].type = REP;
    this.opcodes[209].min = 1;
    this.opcodes[209].max = Infinity;

    this.opcodes[210] = [];
    this.opcodes[210].opNext = 211;
    this.opcodes[210].type = RNM;
    this.opcodes[210].ruleIndex = 26;

    this.opcodes[211] = [];
    this.opcodes[211].opNext = 213;
    this.opcodes[211].type = REP;
    this.opcodes[211].min = 1;
    this.opcodes[211].max = Infinity;

    this.opcodes[212] = [];
    this.opcodes[212].opNext = 213;
    this.opcodes[212].type = RNM;
    this.opcodes[212].ruleIndex = 26;

    this.opcodes[213] = [];
    this.opcodes[213].opNext = 217;
    this.opcodes[213].type = ALT;

    this.opcodes[214] = [];
    this.opcodes[214].opNext = 215;
    this.opcodes[214].type = RNM;
    this.opcodes[214].ruleIndex = 26;

    this.opcodes[215] = [];
    this.opcodes[215].opNext = 216;
    this.opcodes[215].type = TRG;
    this.opcodes[215].min = 97;
    this.opcodes[215].max = 101;

    this.opcodes[216] = [];
    this.opcodes[216].opNext = 217;
    this.opcodes[216].type = TRG;
    this.opcodes[216].min = 65;
    this.opcodes[216].max = 69;

    this.opcodes[217] = [];
    this.opcodes[217].opNext = 218;
    this.opcodes[217].type = TRG;
    this.opcodes[217].min = 48;
    this.opcodes[217].max = 57;

    this.opcodes[218] = [];
    this.opcodes[218].opNext = 221;
    this.opcodes[218].type = ALT;

    this.opcodes[219] = [];
    this.opcodes[219].opNext = 220;
    this.opcodes[219].type = TRG;
    this.opcodes[219].min = 65;
    this.opcodes[219].max = 90;

    this.opcodes[220] = [];
    this.opcodes[220].opNext = 221;
    this.opcodes[220].type = TRG;
    this.opcodes[220].min = 97;
    this.opcodes[220].max = 122;

}

</script>
<!-- include visual regexp builder files -->
<script type="text/javascript">
/* htmlUtil.js */
var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;',
    "/": '&#x2F;'
};

function escapeHtml(string) {
    return String(string).replace(/[&<>"'\/]/g, function(s) {
        return entityMap[s];
    });
}

function gel(id, node) {
    if (node) {
        return node.querySelector("[id='" + id + "']");
    } else {
        return document.getElementById(id);
    }
}

function getSel(id, node) {
    var e = gel(id, node);
    return e.options[e.selectedIndex].value;
}

function getValue(id, node) {
    var e = gel(id, node);
    if (e.tagName == 'SELECT') {
        return getSel(id);
    } else if (e.tagName == 'INPUT') {
        if (e.type == 'checkbox') {
            return e.checked;
        } else {
            return e.value;
        }
    } else if (e.tagName == 'TEXTAREA') {
        return e.value;
    }
    throw "unknown field type " + e.tagName;
}

function setValue(id, value, node) {
    var e = gel(id, node);
    if (e.tagName == 'SELECT') {
        return setSel(id, value, node);
    } else if (e.tagName == 'INPUT') {
        if (e.type == 'checkbox') {
            return e.checked = value ? true : false;
        } else {
            return e.value = value;
        }
    } else if (e.tagName == 'TEXTAREA') {
        return e.value = value;
    }
    throw "unknown field type" + e.tagName;
}

function setSel(id, value, node) {
    var e = gel(id, node);
    for (var i, j = 0; i = e.options[j]; j++) {
        if (i.value == value) {
            e.selectedIndex = j;
            break;
        }
    }
}

</script>
<script type="text/javascript">
/* schema.js */
var currentId = 0;
var selectedItem = null;

function escapeCharFactor(string) {
	return String(string).replace(/[\\ \/\\\[\]{}()?+*|.\^$]/g, '\\$&');
}

function escapeCharClass(string) {
	return String(string).replace(/[\\ \/\\\[\]\^\-]/g, '\\$&');
}

function getItemNum(selectedItem) {
	var t = selectedItem.id.split('-');
	return t[1];
}

/**
 * @param {String}
 *            itemType
 * @returns {Element} new htmlElement of the item
 */
function createNewItem(itemType) {
	var theItem = getItemByType(itemType);
	return duplicateItem(theItem);
}

/**
 * @param {String}
 *            itemType
 * @returns {Element} htmlElement model of the item
 */
function getItemByType(itemType) {
	var tabTypes = document.querySelectorAll('#type-XXX');
	for (var i = 0; i < tabTypes.length; i++) {
		var typeNd = tabTypes[i];
		if (typeNd.value == itemType) {
			return typeNd.parentNode;
		}
	}
	return null;
}

/**
 * @param {Element}
 *            oldNode node to be duplicated
 * @returns {Element} duplicated htmlNode
 */
function duplicateItem(oldNode) {
	var newItem = oldNode.cloneNode(true);
	currentId++;
	newItem.innerHTML = newItem.innerHTML.replace(new RegExp('XXX', 'g'),
			String(currentId));
	newItem.innerHTML = newItem.innerHTML.replace('disabled="disabled"', '');
	newItem.id = newItem.id.replace('XXX', String(currentId));
	newItem.setAttribute("style", "");
	return newItem;
}

function fold(event, field) {
	if (!event.target.checked) {
		gel(field).style.display = 'none';
	} else {
		gel(field).style.display = 'block';
	}
}

function showQuantifierBlock(event) {
	selectedItem = event.target.parentNode;
	var q = gel('quantifierBlock');
	q.style.display = 'block';
	q.style.left = String(event.pageX) + 'px';
	q.style.top = String(event.pageY) + 'px';
	var n = getItemNum(selectedItem);
	var min = gel('min-' + n).value;
	var max = gel('max-' + n).value;
	if ((min == 1) && (max == 1)) {
		gel('quantifierOne').checked = true;
	} else if ((min === '0') && (max === '1')) {
		gel('quantifierOptionnal').checked = true;
	} else if ((min === '0') && (max === '')) {
		gel('quantifierIndefinitelyOpt').checked = true;
	} else if ((min === '1') && (max === '')) {
		gel('quantifierIndefinitely').checked = true;
	} else if (max === '') {
		gel('quantifierAtLeast').checked = true;
		gel('quantifierAtLeastMin').value = min;
	} else if (min === '0') {
		gel('quantifierAtMost').checked = true;
		gel('quantifierAtMostMax').value = max;
	} else if (min === max) {
		gel('quantifierExact').checked = true;
		gel('quantifierExactMin').value = min;
	} else {
		gel('quantifierRepeated').checked = true;
		gel('quantifierRepeatedMin').value = min;
		gel('quantifierRepeatedMax').value = max;
	}
}

function closeQuantifierBlock(event) {
	var q = gel('quantifierBlock');
	q.style.display = 'none';
}

function saveQuantifierBlock(event) {
	var q = gel('quantifierBlock');
	q.style.display = 'none';
	var n = getItemNum(selectedItem);
	if (gel('quantifierOne').checked) {
		gel('min-' + n).value = '1';
		gel('max-' + n).value = '1';
	} else if (gel('quantifierOptionnal').checked) {
		gel('min-' + n).value = '0';
		gel('max-' + n).value = '1';
	} else if (gel('quantifierIndefinitelyOpt').checked) {
		gel('min-' + n).value = '0';
		gel('max-' + n).value = '';
	} else if (gel('quantifierIndefinitely').checked) {
		gel('min-' + n).value = '1';
		gel('max-' + n).value = '';
	} else if (gel('quantifierExact').checked) {
		gel('min-' + n).value = gel('quantifierExactMin').value;
		gel('max-' + n).value = gel('quantifierExactMin').value;
	} else if (gel('quantifierAtLeast').checked) {
		gel('min-' + n).value = gel('quantifierAtLeastMin').value;
		gel('max-' + n).value = '';
	} else if (gel('quantifierAtMost').checked) {
		gel('min-' + n).value = '0';
		gel('max-' + n).value = gel('quantifierAtMostMax').value;
	} else if (gel('quantifierRepeated').checked) {
		gel('min-' + n).value = gel('quantifierRepeatedMin').value;
		gel('max-' + n).value = gel('quantifierRepeatedMax').value;
	}
	setQuantifierText(n);
	refresh();
}

function setQuantifierText(n, node) {
	var min = gel('min-' + n, node).value;
	var max = gel('max-' + n, node).value;
	var txt = '';
	if ((min == 1) && (max == 1)) {
		txt = 'one time';
	} else if ((min === '0') && (max === '1')) {
		txt = 'optionnal';
	} else if ((min === '0') && (max === '')) {
		txt = 'indefinitely optionnal';
	} else if ((min === '1') && (max === '')) {
		txt = 'indefinitely';
	} else if (max === '') {
		txt = 'at least ' + min + ' times';
	} else if (min === '0') {
		txt = 'at most ' + max + ' times';
	} else if (min === max) {
		txt = 'exactly ' + min + ' times';
	} else {
		txt = 'repeated ' + min + ' to ' + max + ' times ';
	}
	gel('quantifier-' + n, node).innerHTML = txt;
}

function loadExampleList() {
	gel("saved_regexp").innerHTML = '';
	for (var i = 0; i < regexpExamples.length; i++) {
		gel("saved_regexp").innerHTML += '<option value="' + i + '">'
				+ regexpExamples[i].name + '</option>';
	}
}

function loadExample(i) {
	setValue('regexp', regexpExamples[i].regexp);
	gel('test').value = regexpExamples[i].tests[0];
	typeRegexp();
}

function delExample() {
	regexpExamples.splice(gel('saved_regexp').selectedIndex, 1);
	localStorage.setItem("examples", JSON.stringify(regexpExamples));
	loadExampleList();
}

function saveExample() {
	var name = prompt("A name for this regexp:");
	if (name) {
		var exmpl = {
			"name" : name,
			"regexp" : getValue('regexp'),
			"tests" : [ getValue('test') ],
			"testsFails" : []
		};
		regexpExamples.push(exmpl);
		localStorage.setItem("examples", JSON.stringify(regexpExamples));
		loadExampleList();
	}
}

function init() {
	selectedItem = gel('schema');
	// localStorage.removeItem("examples");
	if (localStorage.getItem("examples")) {
		regexpExamples = JSON.parse(localStorage.getItem("examples"));
	} else {
		localStorage.setItem("examples", JSON.stringify(regexpExamples));
	}
	loadExampleList();
}

function refresh() {
	var structure = schemaToStructure();
	var regexp = structureToRegexp(structure);
	setValue('regexp', regexp);
	// buildRegexp();
	testRegexp();
}

function typeRegexp() {
	var regexp = getValue('regexp');
	var structure = regexpToStructure(regexp);
	if (!structure) {
		gel('regexp').style.backgroundColor = 'pink';
		gel('errMsg').innerHTML = 'There is an error in your regular expression.';
	} else {
		gel('regexp').style.backgroundColor = 'lightgreen';
		gel('errMsg').innerHTML = '';
		structureToSchema(structure);
		testRegexp();
	}
}

function generateCode() {
	var regexp = getValue('regexp');
	var test = getValue('test');
	var code = '';
	code += 'var myStr = "' + test.replace('"', '\\"') + '";\r\n';
	code += 'var matches = myStr.match(' + regexp + ');\r\n';
	code += 'if (matches !== null) {\r\n';
	code += '    for (var i = 0; i &lt; matches.length; ++i) {\r\n';
	code += '        var match = matches[i];\r\n';
	code += '        // do you code with the match "match" variable\r\n';
	code += '        alert("match: " + match);\r\n';
	code += '    }\r\n';
	code += '} else {\r\n';
	code += '    alert("The regexp does not matches.");\r\n';
	code += '}\r\n';
	gel('code').innerHTML = code;
}

function testRegexp() {
	try {
		var theRegexp = eval(gel('regexp').value);
		var res = gel('test').value.match(theRegexp);
		if (res == null) {
			gel('errMsg').innerHTML = 'Nothing matches in the string.';
			gel('result').value = '';
		} else {
			// gel('result').value = res.join('\n');
			gel('result').value = JSON.stringify(res, null, 4);
			gel('errMsg').innerHTML = '';
		}
		gel('regexp').className = 'regexpOk';
	} catch (e) {
		gel('errMsg').innerHTML = 'Some thing is wrong in the regexp. Error message: '
				+ e.message;
		gel('regexp').className = 'regexpFailed';
	}
	generateCode();
}

/** *************** construct regexp string **************** */
/**
 * @param {Object}
 *            structure
 * @returns String the regexp
 */
function structureToRegexp(structure) {
	var regexp = '/';
	if (structure.atStart) {
		regexp += '^';
	}
	regexp += structureToRegexpRecurs(structure.group);
	if (structure.atEnd) {
		regexp += '$';
	}
	regexp += '/';
	if (structure.global) {
		regexp += 'g';
	}
	if (structure.insensitive) {
		regexp += 'i';
	}
	if (structure.multiline) {
		regexp += 'm';
	}
	return regexp;
}

function structureToRegexpRecurs(itemGroup) {
	var regexp = '';
	for (var i = 0; i < itemGroup.length; i++) {
		var item = itemGroup[i];
		if (item.type == "word") {
			regexp += escapeCharFactor(item.value);
			regexp += structureToRegexpQuantifier(item.min, item.max);
		} else if (item.type == "class") {
			regexp += '[';
			if (item.negative) {
				regexp += '^';
			}
			regexp += structureToRegexpClass(item.group);
			regexp += ']';
			regexp += structureToRegexpQuantifier(item.min, item.max);
		} else if (item.type == "alternative") {
			regexp += '|';
		} else if (item.type == "or") {
			regexp += '(';
			regexp += structureToRegexpRecurs(item.group);
			regexp += ')|(';
			regexp += structureToRegexpRecurs(item.group2);
			regexp += ')';
		} else if (item.type == "group") {
			regexp += '(';
			if (item.capture == 'yes') {
				// regexp += '?:';
			} else if (item.capture == 'no') {
				regexp += '?:';
			} else if (item.capture == '+lookAhead') {
				regexp += '?=';
			} else if (item.capture == '-lookAhead') {
				regexp += '?!';
			}
			regexp += structureToRegexpRecurs(item.group);
			regexp += ')';
			regexp += structureToRegexpQuantifier(item.min, item.max);
		}
	}
	return regexp;
}

function structureToRegexpClass(itemGroup) {
	var regexp = '';
	for (var i = 0; i < itemGroup.length; i++) {
		var item = itemGroup[i];
		if (item.type == "char") {
			regexp += escapeCharClass(item.value);
		} else if (item.type == "predefinedClass") {
			regexp += item.value;
		} else if (item.type == "range") {
			regexp += item.first + '-' + item.last;
		}
	}
	return regexp;
}

function structureToRegexpQuantifier(v1, v2) {
	var regexp = '';
	if (!v1) {
		v1 = 0;
	}
	if (v1 == 0 && v2 == 1) {
		regexp += '?';
	} else if (v1 == 0 && v2 == '') {
		regexp += '*';
	} else if (v1 == 1 && v2 == '') {
		regexp += '+';
	} else if (v1 == 1 && v2 == 1) {
		regexp += '';
	} else if (v1 == v2) {
		regexp += '{' + v1 + '}';
	} else {
		regexp += '{' + v1 + ',' + v2 + '}';
	}
	return regexp;
}

/** *************** construct schema **************** */

/**
 * 
 * @param {Object}
 *            structure
 */
function structureToSchema(structure) {
	gel('schema').innerHTML = "";
	for ( var varName in structure) {
		if ((varName !== 'type') && (varName !== 'group')) {
			setValue(varName, structure[varName]);
		} else if (varName === 'group') {
			for (var i = 0; i < structure['group'].length; i++) {
				var item = structure['group'][i];
				gel('schema').appendChild(structureToSchemaRecurs(item));
			}
		}
	}
}

/**
 * 
 * @param {Object}
 *            item
 * @returns {Node} the new item htmlNode
 */
function structureToSchemaRecurs(item) {
	var itemNode = createNewItem(item['type']);
	var n = getItemNum(itemNode);
	for ( var varName in item) {
		if ((varName !== 'type') && (varName !== 'group')) {
			setValue(varName + '-' + n, item[varName], itemNode);
		} else if (varName === 'group') {
			for (var i = 0; i < item[varName].length; i++) {
				var subItem = item[varName][i];
				gel(varName + '-' + n, itemNode).appendChild(
						structureToSchemaRecurs(subItem));
			}
		}
	}
	setQuantifierText(n, itemNode);
	return itemNode;
}

/** *************** schema To Structure **************** */
/**
 * @returns {ObjectS}
 */
function schemaToStructure() {
	var item = {};
	item.type = "literal";
	item.atStart = getValue('atStart') ? true : false;
	item.atEnd = getValue('atEnd') ? true : false;
	item.global = getValue('global') ? true : false;
	item.insensitive = getValue('insensitive') ? true : false;
	item.multiline = getValue('multiline') ? true : false;
	item.group = schemaToStructureRecurs(gel('schema'));
	return item;
}

function schemaToStructureRecurs(nodeRoot) {
	var nodes = nodeRoot.childNodes;
	var itemTab = [];
	for (var i = 0; i < nodes.length; i++) {
		var node = nodes[i];
		if ((node.nodeType == Node.ELEMENT_NODE)
				&& ((node.className == 'item') || (node.className == 'itemClass'))) {
			var item = {};
			var n = getItemNum(node);
			if (gel('type-' + n).value == "word") {
				item.type = "word";
				item.value = getValue('value-' + n);
				item.min = getValue('min-' + n);
				item.max = getValue('max-' + n);
			} else if (gel('type-' + n).value == "class") {
				item.type = "class";
				item.negative = getValue('negative-' + n) ? true : false;
				item.group = schemaToStructureRecurs(gel('group-' + n));
				item.min = getValue('min-' + n);
				item.max = getValue('max-' + n);
			} else if (gel('type-' + n).value == "alternative") {
				item.type = "alternative";
			} else if (gel('type-' + n).value == "or") {
				item.type = "or";
				item.group = schemaToStructureRecurs(gel('group-' + n));
				item.group2 = schemaToStructureRecurs(gel('group2-' + n));
			} else if (gel('type-' + n).value == "group") {
				item.type = "group";
				item.capture = getValue('capture-' + n);
				item.group = schemaToStructureRecurs(gel('group-' + n));
				item.min = getValue('min-' + n);
				item.max = getValue('max-' + n);
			} else if (gel('type-' + n).value == "char") {
				item.type = "char";
				item.value = getValue('value-' + n);
			} else if (gel('type-' + n).value == "predefinedClass") {
				item.type = "predefinedClass";
				item.value = getValue('value-' + n);
			} else if (gel('type-' + n).value == "range") {
				item.type = "range";
				item.first = getValue('first-' + n);
				item.last = getValue('last-' + n);
			}
			itemTab.push(item);
		}
	}
	return itemTab;
}

/** *************** drag n drop **************** */

var dragged;

function drag(event) {
	event.dataTransfer.setData('text/plain', null);
}

/* events fired on the draggable target */
document.addEventListener("drag", function(event) {

}, false);

document.addEventListener("dragstart", function(event) {
	// store a ref. on the dragged elem
	dragged = event.target;
	// make it half transparent
	event.target.style.opacity = .5;
}, false);

document.addEventListener("dragend", function(event) {
	// reset the transparency
	event.target.style.opacity = "";
}, false);

/* events fired on the drop targets */
document.addEventListener("dragover", function(event) {
	// prevent default to allow drop
	event.preventDefault();
}, false);

document.addEventListener("dragenter", function(event) {
	// highlight potential drop target when the draggable element enters it
	var source = dragged.parentNode;
	var dest = event.target;
	var elem = dragged;

	// move dragged elem to the selected drop target
	if (isValidMove(source, dest, elem)) {
		if (dest.style) {
			if (dest.id == 'recycledBin') {
				dest.className = "group recycledBinFull";
			} else {
				dest.style.background = "chartreuse";
			}
		}
	} else {
		if (dest.style) {
			if (dest.id == 'recycledBin') {
				dest.className = "group";
			} else {
				dest.style.background = "red";
			}
		}
	}
}, false);

document.addEventListener("dragleave", function(event) {
	// reset background of potential drop target when the draggable element
	// leaves it
	// var source = dragged.parentNode;
	var dest = event.target;
	// var elem = dragged;
	if (dest.style) {
		if (dest.id == 'recycledBin') {
			dest.className = "group";
		} else {
			dest.style.background = "";
		}
	}

}, false);

document.addEventListener("drop", function(event) {
	// prevent default action (open as link for some elements)
	event.preventDefault();
	var source = dragged.parentNode;
	var dest = event.target;
	var elem = dragged;
	if (dest.style) {
		if (dest.id == 'recycledBin') {
			dest.className = "group";
		} else {
			dest.style.background = "";
		}
	}
	// move dragged elem to the selected drop target
	if (isValidMove(source, dest, elem)) {
		doMove(source, dest, elem);
	}

}, false);

function isValidMove(source, dest, elem) {
	if (dest == elem) {
		// dragged in the same node
		return false;
	}
	if ((dest.id == 'ressources') || (dest.parentNode.id == "ressources")
			|| (dest.parentNode.parentNode.id == "ressources")) {
		return false;
	}
	// move dragged elem to the selected drop target
	if (dest.id == 'recycledBin') {
		if (source.id == "ressources") {
			return false;
		}
		return true;
	}
	if ((dest.className == "group") || (dest.parentNode.className == "group")) {
		if (elem.className == "item") {
			return true;
		}
	} else if ((dest.className == "groupClass")
			|| (dest.parentNode.className == "groupClass")) {
		if (elem.className == "itemClass") {
			return true;
		}
	}
	return false;
}

function doMove(source, dest, elem) {
	if (source.id == 'ressources') {
		elem = duplicateItem(elem);
	} else {
		source.removeChild(elem);
	}
	if (dest.id != 'recycledBin') {
		if ((dest.parentNode.className == "group")
				|| (dest.parentNode.className == "groupClass")) {
			dest.parentNode.insertBefore(elem, dest);
		} else {
			dest.appendChild(elem);
		}
	}
	refresh();
}

</script>
<script type="text/javascript">
/* visual-regexp-builder.js */
/**
HTML Requirements:
  A web page (or pages) capable of:
   - capturing the input string to be parsed
   - running the JavaScript parser
   - displaying the output

The web page must have the following elements:
1. required - include APG library
2. required - include generated parser
3. optional - user-written JavaScript syntax call back functions
4. optional - user-written JavaScript semantic call back functions
5. required - user-written JavaScript driver "main" program

The main function below performs the following steps:
function main()
{
    1. intitialize
       - parser opcodes
       - the parser
       - a message log
       - the syntax call back functions
       - the semantic call back functions
       - the AST
       - the input string
       - the parsing statistics
       - the parser trace
    2. parse input string - syntax analysis
    3. translate the input string - semantic analysis
       - display the translation
    4. display
       - the parser's final state
       - the parsing statistics
       - the parser trace
       - selected parsed phrases
}
*/
// /////////////////////////////////////////////////////////////////////////////
// 3. syntax call back functions
// /////////////////////////////////////////////////////////////////////////////
// state is an array, call back function may change the parser state and/or the matched character count
// state[OP_STATE] - APG_ACTIVE, APG_MATCH, APG_EMPTY or APG_NOMATCH - the state of the parser
// state[OP_MATCHED] - the number of characters in the matched phrase (if state = APG_MATCH or APG_EMPTY)
// chars - an array of character codes for the input string
// phraseIndex - the index of the first character of the phrase being examined
// e.g. chars[phraseIndex] is the first character code of the phrase
// data - user-defined data, specified in parser call to "syntaxAnalysis()"
/**
 * @param state
 * @param chars
 * @param phraseIndex
 * @param data
 * 
 */
function synSectionName(state, chars, phraseIndex, data) {
    // handwritten parser to eliminate lots of calls to alpha & digit
    if (state[OP_STATE] == APG_ACTIVE) {
        var i, count = 0;
        for (i = phraseIndex; i < chars.length; i += 1) {
            var thisChar = chars[i];
            if ((thisChar >= 65 && thisChar <= 90) || (thisChar >= 97 && thisChar <= 122) || (thisChar >= 48 && thisChar <= 57) || (thisChar == 95)) {
                count += 1;
            } else {
                break;
            }
        }
        if (count > 0) {
            state[OP_STATE] = APG_MATCH;
            state[OP_MATCHED] = count;
        } else {
            state[OP_STATE] = APG_NOMATCH;
            state[OP_MATCHED] = 0;
        }
    }
}
function synValueName(state, chars, phraseIndex, data) {
    // handwritten parser to eliminate lots of calls to alpha & digit
    if (state[OP_STATE] == APG_ACTIVE) {
        var i, count = 0;
        for (i = phraseIndex; i < chars.length; i += 1) {
            var thisChar = chars[i];
            if ((thisChar >= 65 && thisChar <= 90) || (thisChar >= 97 && thisChar <= 122) || (thisChar >= 48 && thisChar <= 57) || (thisChar == 95)) {
                count += 1;
            } else {
                break;
            }
        }
        if (count > 0) {
            state[OP_STATE] = APG_MATCH;
            state[OP_MATCHED] = count;
        } else {
            state[OP_STATE] = APG_NOMATCH;
            state[OP_MATCHED] = 0;
        }
    }
}
function synAlphaDigit(state, chars, phraseIndex, data) {
    // handwritten parser to eliminate lots of calls to alpha & digit
    if (state[OP_STATE] == APG_ACTIVE) {
        var i, count = 0;
        for (i = phraseIndex; i < chars.length; i += 1) {
            var thisChar = chars[i];
            if ((thisChar >= 65 && thisChar <= 90) || (thisChar >= 97 && thisChar <= 122) || (thisChar >= 48 && thisChar <= 57)) {
                count += 1;
            } else {
                break;
            }
        }
        if (count > 0) {
            state[OP_STATE] = APG_MATCH;
            state[OP_MATCHED] = count;
        } else {
            state[OP_STATE] = APG_NOMATCH;
            state[OP_MATCHED] = 0;
        }
    }
}
function synBadSectionLine(state, chars, phraseIndex, data) {
    // error reporting on discovery of a bad section line
    if (state[OP_STATE] == APG_MATCH) {
        data.log.logMsg('bad section line at line number: ' + data.lineno);
    }
}
function synBadValueLine(state, chars, phraseIndex, data) {
    // error reporting on discovery of a bad value line
    if (state[OP_STATE] == APG_MATCH) {
        data.log.logMsg('bad value line at line number: ' + data.lineno);
    }
}
function synLineEnd(state, chars, phraseIndex, data) {
    // counts the input string line numbers
    if (state[OP_STATE] == APG_MATCH) {
        data.lineno += 1;
    }
}
function SyntaxCallbacks(ruleIds) {
    // must be called prior to syntax analysis
    this.init = function(chars, log) {
        this.chars = chars; // the input string characters (array of ASCII character codes, not a string)
        this.log = log; // a msgLog() object
        this.lineno = 0; // the current line number, for error reporting
    };
    
    // ruleID - from the grammar opcodes
    // synList - an empty array for the call back function pointers
    this.callbackList = function(ruleID, synList) {
        // clear all call back functions
        for (var i = 0; i < ruleID.length; i += 1) {
            synList[i] = false;
        }
        
        // specify only the call back functions that have been defined
        synList[ruleID["badsectionline"]] = synBadSectionLine;
        synList[ruleID["badvalueline"]] = synBadValueLine;
        synList[ruleID["sectionname"]] = synSectionName;
        synList[ruleID["valuename"]] = synValueName;
        synList[ruleID["alphadigit"]] = synAlphaDigit;
        synList[ruleID["lineend"]] = synLineEnd;
    };
    this.chars = null; // the input string characters
    this.log = null; // a msgLog() object
    this.lineno = 0; // the current line number, for error reporting
    this.synList = []; // the list of syntax call back function pointers
    this.callbackList(ruleIds, this.synList); // initialize the call back function list
}

// /////////////////////////////////////////////////////////////////////////////
// 4. semantic call back functions
// /////////////////////////////////////////////////////////////////////////////

// state - APG_PRE, APG_POST - the direction of AST traversal (APG_PRE = down, APG_POST = up)
// chars - an array of character codes for the input string
// phraseIndex - the index of the first character of the phrase being examined
// e.g. chars[phraseIndex] is the first character code of the phrase
// phraseCount - the number of characters in the matched phrase
// data - user-defined data, specified in parser call to "semanticAnalysis()"
function semGeneric(state, chars, phraseIndex, phraseCount, data, ruleName) {
    var ret = APG_SEM_OK;
    if (state == APG_PRE) {
        data.xmlTree += '<' + ruleName + '>'/* + '\r\n' */;
        if (ruleName === 'regexpquantifier') {
            var char1 = charsToString(chars, phraseIndex, 1);
            if (char1 !== '{') {
                data.xmlTree += char1/* + '\r\n' */;
            }
        }
    }
    if (state == APG_POST) {
        data.xmlTree += '</' + ruleName + '>'/* + '\r\n' */;
    }
    return ret;
}

function semGenericSingle(state, chars, phraseIndex, phraseCount, data, ruleName) {
    var ret = APG_SEM_OK;
    if (state == APG_POST) {
        data.xmlTree += '<' + ruleName + ' />'/* + '\r\n' */;
    }
    return ret;
}

function semGenericContent(state, chars, phraseIndex, phraseCount, data, ruleName) {
    var ret = APG_SEM_OK;
    if (state == APG_PRE) {
        data.xmlTree += '<' + ruleName + '>'/* + '\r\n' */;
    }
    if (state == APG_POST) {
        data.xmlTree += escapeHtml(charsToString(chars, phraseIndex, phraseCount))/* + '\r\n' */;
        data.xmlTree += '</' + ruleName + '>'/* + '\r\n' */;
    }
    return ret;
}

// log - a message log object
// ruleIds - the rule ID array from the APG-generated opcodes
function SemCallbacks(log, ruleIds) {
    // ruleIds - the rule ID array from the APG-generated opcodes
    // semList - an empty array for the array of call back function pointers
    this.callbackList = function(ruleID, semList) {
        for (var i = 0; i < ruleID.length; i += 1) {
            semList[i] = false;
        }
        
        semList[ruleID["regexpliteral"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpliteral");
        };
        semList[ruleID["regexpatstart"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericSingle(state, chars, phraseIndex, phraseCount, data, "regexpatstart");
        };
        semList[ruleID["regexpatend"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericSingle(state, chars, phraseIndex, phraseCount, data, "regexpatend");
        };
        semList[ruleID["regexpoptions"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericContent(state, chars, phraseIndex, phraseCount, data, "regexpoptions");
        };
        semList[ruleID["regexpgroupcapture"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericContent(state, chars, phraseIndex, phraseCount, data, "regexpgroupcapture");
        };
        semList[ruleID["regexpclassnegative"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericSingle(state, chars, phraseIndex, phraseCount, data, "regexpclassnegative");
        };
        // semList[ruleID["regexpchoice"]] = function(state, chars, phraseIndex, phraseCount, data) {
        // return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpchoice");
        // };
        semList[ruleID["regexpsequence"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpsequence");
        };
        semList[ruleID["regexpalternative"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericSingle(state, chars, phraseIndex, phraseCount, data, "regexpalternative");
        };
        // semList[ruleID["regexpfactor"]] = function(state, chars, phraseIndex, phraseCount, data) {
        // return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpfactor");
        // };
        semList[ruleID["regexpgroup"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpgroup");
        };
        semList[ruleID["regexpclass"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpclass");
        };
        semList[ruleID["regexpcharrange"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpcharrange");
        };
        semList[ruleID["regexpcharstart"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericContent(state, chars, phraseIndex, phraseCount, data, "regexpcharstart");
        };
        semList[ruleID["regexpcharend"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericContent(state, chars, phraseIndex, phraseCount, data, "regexpcharend");
        };
        semList[ruleID["regexpquantifier"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpquantifier");
        };
        semList[ruleID["regexpquantifierrange"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGeneric(state, chars, phraseIndex, phraseCount, data, "regexpquantifierrange");
        };
        semList[ruleID["regexpclassword"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericContent(state, chars, phraseIndex, phraseCount, data, "regexpclassword");
        };
        semList[ruleID["regexpfactorword"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericContent(state, chars, phraseIndex, phraseCount, data, "regexpfactorword");
        };
        semList[ruleID["min"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericContent(state, chars, phraseIndex, phraseCount, data, "min");
        };
        semList[ruleID["max"]] = function(state, chars, phraseIndex, phraseCount, data) {
            return semGenericContent(state, chars, phraseIndex, phraseCount, data, "max");
        };
    };
    
    // semList - a complete array of call back function pointers
    // astList - an empty array for the AST's list of nodes
    this.astNodeList = function(semList, astList) {
        for (var i = 0; i < semList.length; i += 1) {
            if (semList[i]) {
                astList[i] = true;
            } else {
                astList[i] = false;
            }
        }
    };
    
    this.xmlTree = "";
    this.log = log;
    this.astList = [];
    this.semList = [];
    this.callbackList(ruleIds, this.semList);
    this.astNodeList(this.semList, this.astList);
}

var xmlToJson = {};

/**
 * 
 * @param {Node} rootNode
 * @returns {Object}
 */
xmlToJson.parse = function(rootNode) {
    return xmlToJson.regexpliteral(rootNode.firstChild);
};

xmlToJson.regexpliteral = function(rootNode) {
    var ret = {};
    ret.type = "literal";
    ret.global = false;
    ret.insensitive = false;
    ret.multiline = false;
    ret.atStart = false;
    ret.atEnd = false;
    ret.group = [];
    for (var i = 0; i < rootNode.childNodes.length; i++) {
        var node = rootNode.childNodes[i];
        if (node.nodeName == "regexpatstart") {
            ret.atStart = true;
        } else if (node.nodeName == "regexpatend") {
            ret.atEnd = true;
        } else if ((node.nodeName == "regexpoptions") && (node.firstChild)) {
            if (node.firstChild.nodeValue.indexOf('g') !== -1) {
                ret.global = true;
            }
            if (node.firstChild.nodeValue.indexOf('i') !== -1) {
                ret.insensitive = true;
            }
            if (node.firstChild.nodeValue.indexOf('m') !== -1) {
                ret.multiline = true;
            }
        } else if (node.nodeName == "regexpalternative") {
            ret.group.push({
                "type": "alternative"
            });
        } else if (node.nodeName == "regexpsequence") {
            ret.group = ret.group.concat(xmlToJson.regexpsequence(node));
        }
    }
    return ret;
};

xmlToJson.regexpsequence = function(rootNode) {
    var tab = [];
    var lastItem = null;
    for (var i = 0; i < rootNode.childNodes.length; i++) {
        var node = rootNode.childNodes[i];
        if (node.nodeName == "regexpclass") {
            lastItem = xmlToJson.regexpclass(node);
            tab.push(lastItem);
        } else if (node.nodeName == "regexpgroup") {
            lastItem = xmlToJson.regexpgroup(node);
            tab.push(lastItem);
        } else if (node.nodeName == "regexpfactorword") {
            lastItem = {
                "type": "word",
                "value": node.firstChild.nodeValue
            };
            tab.push(lastItem);
        } else if (node.nodeName == "regexpquantifier") {
            if (lastItem) {
                lastItem.min = "1";
                lastItem.max = "1";
                if (node.firstChild.nodeType == Node.TEXT_NODE) {
                    if (node.firstChild.nodeValue.trim() === '?') {
                        lastItem.min = "0";
                        lastItem.max = "1";
                    } else if (node.firstChild.nodeValue.trim() === '+') {
                        lastItem.min = "1";
                        lastItem.max = "";
                    } else if (node.firstChild.nodeValue.trim() === '*') {
                        lastItem.min = "0";
                        lastItem.max = "";
                    }
                } else {
                    var n = node.getElementsByTagName('min');
                    if (n && n[0]) {
                        lastItem.min = n[0].firstChild.nodeValue.trim();
                        n = node.getElementsByTagName('max');
                        if (n && n[0]) {
                            lastItem.max = n[0].firstChild.nodeValue.trim();
                        } else {
                            lastItem.max = lastItem.min;
                        }
                    }
                }
            }
        }
    }
    return tab;
};

xmlToJson.regexpclass = function(rootNode) {
    var ret = {};
    ret.type = "class";
    ret.negative = false;
    ret.group = [];
    for (var i = 0; i < rootNode.childNodes.length; i++) {
        var node = rootNode.childNodes[i];
        if (node.nodeName == "regexpclassnegative") {
            ret.negative = true;
        } else if (node.nodeName == "regexpcharrange") {
            var lastItem = {};
            lastItem.type = "range";
            var n = node.getElementsByTagName('regexpcharstart');
            if (n && n[0]) {
                lastItem.first = n[0].firstChild.nodeValue.trim();
            }
            n = node.getElementsByTagName('regexpcharend');
            if (n && n[0]) {
                lastItem.last = n[0].firstChild.nodeValue.trim();
            }
            ret.group.push(lastItem);
        } else if (node.nodeName == "regexpclassword") {
            ret.group.push({
                "type": "char",
                "value": node.firstChild.nodeValue
            });
        }
    }
    return ret;
};

xmlToJson.regexpgroup = function(rootNode) {
    var ret = {};
    ret.type = "group";
    ret.capture = "yes";
    ret.group = [];
    for (var i = 0; i < rootNode.childNodes.length; i++) {
        var node = rootNode.childNodes[i];
        //
        if (node.nodeName == "regexpgroupcapture") {
            if (node.firstChild.nodeValue.trim() === '?:') {
                ret.capture = "no";
            } else if (node.firstChild.nodeValue.trim() === '?=') {
                ret.capture = "+lookAhead";
            } else if (node.firstChild.nodeValue.trim() === '?!') {
                ret.capture = "-lookAhead";
            }
        } else if (node.nodeName == "regexpalternative") {
            ret.group.push({
                "type": "alternative"
            });
        } else if (node.nodeName == "regexpsequence") {
            ret.group = ret.group.concat(xmlToJson.regexpsequence(node));
        }
    }
    return ret;
};

var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;',
    "/": '&#x2F;'
};

function escapeHtml(string) {
    return String(string).replace(/[&<>"'\/]/g, function(s) {
        return entityMap[s];
    });
}

// /////////////////////////////////////////////////////////////////////////////
// 5. driver "main" program
// /////////////////////////////////////////////////////////////////////////////
function regexpToStructure(regexp) {
    // clear the output string
    var html = '';
    
    // initialize the APG-generated opcodes
    var parserOpcodes = new ABNFOpcodes();
    
    // initialize the parser
    var parser = new ApgLib(parserOpcodes.stringTable, parserOpcodes.rules, parserOpcodes.opcodes);
    
    // initialize the syntax call back functions
    var log = new MsgLog();
    var synCallbacks = new SyntaxCallbacks(parserOpcodes.ruleIds);
    // EXERCISE: Reduce the node count with handwritten parsers for selected rules
    // 1.Comment out the syntaxInit() line below so that there are no syntax call back functions called
    // 2.Parse the input string
    // 3.Note the statistics: TOTAL/ALL and the rule name counts for "alpha" and "digit"
    // 4.Now un-comment the syntaxInit() line and parse the same string again with syntax call back functions
    // 5.Note again the statistics. There should be a big reduction in the TOTAL/ALL count
    // and the "alpha" and "digit" counts should be zero (absent from the list)
    parser.syntaxInit(synCallbacks.synList);
    
    // get and preprocess the input string
    var stringChars = [];
    grammarToChars(log, regexp, stringChars);
    
    // NOTE: Some browsers will add line ending characters to the textarea content.
    // If in doubt, you can check it by un-commenting the following lines:
    // html += '<br /><br />input string chars:';
    // for(var i = 0; i < stringChars.length; i +=1)
    // {
    // html += '<br />';
    // html += 'i: '+i+' char: '+stringChars[i];
    // }
    
    // initialize the semantic call back functions
    var semCallbacks = new SemCallbacks(log, parserOpcodes.ruleIds);
    parser.semanticInit(semCallbacks.semList);
    
    // initialize the AST (required for semantic analysis)
    var ast = new Ast(semCallbacks.astList, parserOpcodes.rules, stringChars);
    parser.astInit(ast);
    
    // initialize the parser statistics
    var parserStats = new Stats(parserOpcodes.rules);
    parser.statsInit(parserStats);
    
    // initialize the parser trace
    var parserTrace = new Trace();
    parserTrace.initRules(parserOpcodes.rules);
    parserTrace.initChars(stringChars);
    parser.traceInit(parserTrace);
    parserTrace.setFilter(parserTrace.parseFilter, 'tls', true); // turn on TLS operator for trace record saving
    parserTrace.setFilter(parserTrace.displayFilter, 'tls', true); // turn on TLS operator for trace record display
    parserTrace.setFilter(parserTrace.parseFilter, 'rule', false, 18); // turn off wsp
    parserTrace.setFilter(parserTrace.parseFilter, 'rule', false, 21); // turn off any
    
    // parse the string
    synCallbacks.init(stringChars, log);
    var test = parser.syntaxAnalysis(0, stringChars, synCallbacks);
    var structure = {};
    
    if (log.count() !== 0) {
        html += log.logDisplay('syntaxAnalysis analysis errors encountered');
        return null;
    }
    if (!test) {
        html += 'There is an error in your regular expression.';
        return null;
    }
    
    // translate the string - semantic analysis
    parser.semanticAnalysis(semCallbacks);
    if (log.count() !== 0) {
        html += log.logDisplay('semanticAnalysis analysis errors encountered');
        return null;
    }
    
    var oParser = new DOMParser();
    var oDOM = oParser.parseFromString(semCallbacks.xmlTree, "text/xml");
    
    structure = xmlToJson.parse(oDOM);
    
    return structure;
}

</script>
<script type="text/javascript">
/* examples.js */
var regexpExamples = [
    {
        "name": "empty",
        "regexp": "//",
        "tests": [
            ""
        ],
        "testsFails": [
            "42"
        ]
    },
    {
        "name": "IP v4",
        "regexp": "/(\[0-9]{1,3}\\.){3}[0-9]{1,3}/",
        "tests": [
            "127.0.0.1",
            "192.168.1.254",
            "8.8.8.8",
            "255.255.255.255"
        ],
        "testsFails": [
            "8.8.8",
            "8.8.d",
            "8.8.8..8"
        ]
    },
    {
        "name": "e-mail",
        "regexp": "/^[a-z0-9][a-z0-9_.\\-]*@[a-z0-9][a-z0-9.\\-]*[a-z0-9]{2,}$/i",
        "tests": [
            "moi@toi.fr",
            "m-._@t-o.i.fr",
            "john.doe@perdu.com",
            "docteur-who@torchwood.co.uk"
        ],
        "testsFails": [
            "-john.doe@perdu.com",
            "cline@perdu.com",
            "john.doe@perdu.u",
            "john.doe@-perdu.im"
        ]
    }

];

</script>
<!-- JOSN for debug -->
<script type="text/javascript">
/* json2.js */
/*
    json2.js
    2013-05-26

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function () {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

</script>
</head>
<body>
	<h1>Visual RegExp builder</h1>
	<div>Drag and drop blocks in the schema or type your regular expression in the field "the regexp".</div>
	<div id="quantifierBlock">
		<button onclick="closeQuantifierBlock()" style="float: right;">X</button>
		<input type="radio" name="quantifierRadio" id="quantifierOne" value="optionnal" />
		one time
		<br />
		<input type="radio" name="quantifierRadio" id="quantifierOptionnal" value="optionnal" />
		optionnal
		<br />
		<input type="radio" name="quantifierRadio" id="quantifierIndefinitelyOpt" value="indefinitelyOpt" />
		repeated indefinitely many times optionnal
		<br />
		<input type="radio" name="quantifierRadio" id="quantifierIndefinitely" value="indefinitely" />
		repeated indefinitely many times
		<br />
		<input type="radio" name="quantifierRadio" id="quantifierExact" value="atLeast" />
		exactly
		<input type="text" id="quantifierExactMin" value="2" size="2" />
		times<br />
		<input type="radio" name="quantifierRadio" id="quantifierAtLeast" value="atLeast" />
		at least
		<input type="text" id="quantifierAtLeastMin" value="2" size="2" />
		times<br />
		<input type="radio" name="quantifierRadio" id="quantifierAtMost" value="atMost" />
		at most
		<input type="text" id="quantifierAtMostMax" value="3" size="2" />
		times<br />
		<input type="radio" name="quantifierRadio" id="quantifierRepeated" value="repeated" />
		repeated
		<input type="text" id="quantifierRepeatedMin" value="2" size="2" />
		to
		<input type="text" id="quantifierRepeatedMax" value="4" size="2" />
		times
		<button onclick="saveQuantifierBlock()" style="float: right;">Ok</button>
	</div>
	<table id="design">
		<tr>
			<td>
				<input type="checkbox" id="atStart" value="1" onchange="refresh()" />
				At begining of string/line<br />
				<fieldset class="mainGroup">
					<legend> The schema </legend>
					<div id="schema" class="group"></div>
				</fieldset>
				<input type="checkbox" id="atEnd" value="1" onchange="refresh()" />
				At end of string/line<br /> Options:
				<ul>
					<li><input type="checkbox" id="global" value="1" onchange="refresh()" />Global match (match several times)</li>
					<li><input type="checkbox" id="insensitive" value="1" onchange="refresh()" />Ignore case</li>
					<li><input type="checkbox" id="multiline" value="1" onchange="refresh()" />Working over multiple lines</li>
				</ul>
			</td>
			<td>
				<fieldset class="mainGroup">
					<legend>Recycled bin</legend>
					<div id="recycledBin" class="group"></div>
				</fieldset>
				<fieldset>
					<legend>Saved regexps</legend>
					<select id="saved_regexp" onchange="loadExample(this.selectedIndex)" size="5">
					</select>
					<button onclick="delExample()">del</button>
				</fieldset>
			</td>
			<td>
				<fieldset class="mainGroup">
					<legend>Ressources</legend>
					<div id="ressources" class="group">
						<div id="item-XXX" class="item" ondragstart="drag(event)" draggable="true">
							<input type="hidden" id="type-XXX" value="word" />
							Word
							<input type="text" id="value-XXX" value="Hello" onkeyup="refresh()" onfocus="this.parentNode.draggable=false" onblur="this.parentNode.draggable=true" />
							<input type="hidden" id="min-XXX" value="1" />
							<input type="hidden" id="max-XXX" value="1" />
							<button onclick="showQuantifierBlock(event)" id="showQuantifier-XXX" disabled="disabled">how many</button>
							<div id="quantifier-XXX" class="quantifier">one time</div>
						</div>

						<div id="item-XXX" class="itemClass" ondragstart="drag(event)" draggable="true">
							<input type="hidden" id="type-XXX" value="char" />
							one of theses char
							<input type="text" id="value-XXX" value="aeiouy" onkeyup="refresh()" />
						</div>

						<div id="item-XXX" class="itemClass" ondragstart="drag(event)" draggable="true">
							<input type="hidden" id="type-XXX" value="predefinedClass" />
							one char
							<select id="value-XXX" onchange="refresh()">
								<option value="\d">digit</option>
								<option value="\s">whitespace</option>
								<option value="\w">word character</option>
								<option value="\t">tab</option>
								<option value="\n">new line</option>
								<option value="\r">carriage return</option>
								<option value="\f">form feed</option>
								<option value="\b">backspace</option>
								<option value="a-z">alpha lower case</option>
								<option value="A-Z">alpha upper case</option>
								<option value="a-zA-Z">alpha upper and lower</option>
								<option value="a-zA-Z0-9">alphanum</option>
								<option value="a-f0-9">hexadecimal lowercase</option>
								<option value="A-F0-9">hexadecimal uppercase</option>
								<option value="a-fA-F0-9">hexa upper and lower</option>
							</select>
						</div>

						<div id="item-XXX" class="itemClass" ondragstart="drag(event)" draggable="true">
							<input type="hidden" id="type-XXX" value="range" />
							from char
							<input type="text" id="first-XXX" value="a" size="2" onkeyup="refresh()" />
							to char
							<input type="text" id="last-XXX" value="z" size="2" onkeyup="refresh()" />
						</div>

						<div id="item-XXX" class="item" ondragstart="drag(event)" draggable="true">
							<input type="hidden" id="type-XXX" value="class" />
							(Not
							<input type="checkbox" id="negative-XXX" value="1" onchange="refresh()" />
							) one char of this list
							<input type="hidden" id="min-XXX" value="1" />
							<input type="hidden" id="max-XXX" value="1" />
							<button onclick="showQuantifierBlock(event)" id="showQuantifier-XXX" disabled="disabled">how many</button>
							<div id="quantifier-XXX" class="quantifier">one time</div>
							<div id="group-XXX" class="groupClass"></div>
						</div>

						<div id="item-XXX" class="item" ondragstart="drag(event)" draggable="true" style="display: none;">
							<div id="group-XXX" class="group"></div>
							<input type="hidden" id="type-XXX" value="or" />
							OR
							<div id="group2-XXX" class="group"></div>
						</div>

						<div id="item-XXX" class="item" ondragstart="drag(event)" draggable="true">
							<input type="hidden" id="type-XXX" value="alternative" />
							OR
						</div>

						<div id="item-XXX" class="item" ondragstart="drag(event)" draggable="true">
							<input type="hidden" id="type-XXX" value="group" />
							Group (capturing
							<select id="capture-XXX" onchange="refresh()">
								<option value="yes">Yes</option>
								<option value="no">No</option>
								<option value="+lookAhead">Positive lookAhead</option>
								<option value="-lookAhead">Negative lookAhead</option>
							</select>
							)
							<input type="hidden" id="min-XXX" value="1" />
							<input type="hidden" id="max-XXX" value="1" />
							<button onclick="showQuantifierBlock(event)" id="showQuantifier-XXX" disabled="disabled">how many</button>
							<div id="quantifier-XXX" class="quantifier">one time</div>
							<div id="group-XXX" class="group"></div>
						</div>
					</div>
				</fieldset>
			</td>
		</tr>
	</table>
	<fieldset>
		<legend> The regexp </legend>
		<input type="text" id="regexp" value="" onkeyup="typeRegexp()" />
		<button onclick="saveExample()">save</button>
	</fieldset>
	<hr />
	<table>
		<tr>
			<td>
				<div id="errMsg"></div>
			</td>
		</tr>
		<tr>
			<td>
				<fieldset>
					<legend> Test string </legend>
					<textarea id="test" onkeyup="testRegexp()"></textarea>
				</fieldset>
			</td>
			<td>
				<fieldset>
					<legend> Result </legend>
					<textarea id="result"></textarea>
				</fieldset>
			</td>
		</tr>
		<tr>
			<td>
				<fieldset id="codeFieldset">
					<legend><input type="checkbox" onclick="fold(event, 'code')" />Code</legend>
					<textarea id="code"></textarea>
				</fieldset>
			</td>
		</tr>
	</table>
</body>
<script type="text/javascript">
    init();
</script>
</html>

